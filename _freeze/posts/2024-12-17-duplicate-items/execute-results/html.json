{
  "hash": "aedbfa58c174d2324e7f188c921de022",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Duplicate Items\ndate: '2024-12-17'\ncategories:\n  - dsa\n  - algorithms\n  - data-structures\n  - basics\ndescription: Analysis of different ways to solve finding duplicate items in an unsorted list\ntoc: true\nlayout: post\nformat:\n  html:\n    html-math-method: katex\n---\n\n# Contains Duplicate\n\n## Problem\n\nGiven an unsorted array of integers, determine if any value appears more than once. The function should return true if any value appears at least twice in the array, and false if every element is distinct.\n\nExample 1:\n```\nInput: nums = [1, 2, 3, 3]\n\nOutput: true\n```\n\nExample 2:\n```\nInput: nums = [1, 2, 3, 4]\n\nOutput: false\n```\n\nIdeally the solution would have $O(n)$ space and time complexity.\n\n\n## Initial Solution - Set Based Approach  \n\n::: {#bc92c517 .cell execution_count=1}\n``` {.python .cell-code}\ndef hasDuplicate(nums: list[int]) -> bool:\n    items = set(nums)\n    return len(items) != len(nums)\n\nprint('[1,2,3,3]',hasDuplicate([1,2,3,3]))\nprint('[1,2,3,4]',hasDuplicate([1,2,3,4]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1,2,3,3] True\n[1,2,3,4] False\n```\n:::\n:::\n\n\n### Complexity Analysis  \n  \n1. Creating a set from a list (items = set(nums)):  \n   - Python's set creation involves hashing each element i.e. for each element, Python must:  \n     - Compute the hash value ($O(1)$ for integers)  \n     - Handle potential hash collisions  \n     - Potentially resize the hash table  \n   - amortised time complexity is $O(n)$, but individual operations might take longer due to rehashing  \n  \n2. Length operations (len(items) and len(nums)):  \n   - Both len() operations are $O(1)$ in Python  \n   - Python maintains a length counter for both lists and sets\n   - No iteration is required to get the length\n\nThe overall complexity is $O(n)$; constant factors involved in set creation can be significant due to the hashing overhead.\nSpace complexity is $O(n)$ as we store each unique element in the set.\n\n## Modified Initial Solution - Exit Early Set Based Approach  \n\nThe initial solution could be modified to exit early:\n\n::: {#509abc60 .cell execution_count=2}\n``` {.python .cell-code}\ndef hasDuplicate(nums: list[int]) -> bool:\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return True\n        seen.add(num)\n    return False\n\nprint('[1,2,3,3]',hasDuplicate([1,2,3,3]))\nprint('[1,2,3,4]',hasDuplicate([1,2,3,4]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1,2,3,3] True\n[1,2,3,4] False\n```\n:::\n:::\n\n\nThis approach can be more efficient:  \n- It stops immediately upon finding a duplicate and the set grows only until a duplicate is found  \n- Each set operation (in/add) is amortised $O(1)$  \n\n## Alternative Solution - Counter Approach  \n\n::: {#dcba178a .cell execution_count=3}\n``` {.python .cell-code}\nfrom collections import Counter\n\ndef hasDuplicate(nums: list[int]) -> bool:\n    counter = Counter(nums)\n    return any(count > 1 for count in counter.values())\n\nprint('[1,2,3,3]',hasDuplicate([1,2,3,3]))\nprint('[1,2,3,4]',hasDuplicate([1,2,3,4]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1,2,3,3] True\n[1,2,3,4] False\n```\n:::\n:::\n\n\n## Alternative Solution - Optimising for Space\n\nIf the input array is mutable, we can sort the array with $O(n \\log n)$ time, with the trade off for reduced space of $O(1)$:\n\n::: {#9cce2faf .cell execution_count=4}\n``` {.python .cell-code}\ndef hasDuplicate(nums: list[int]) -> bool:\n    if not nums:\n        return False\n    nums.sort()\n    return any(nums[i] == nums[i+1] for i in range(len(nums)-1))\n\nprint('[1,2,3,3]',hasDuplicate([1,2,3,3]))\nprint('[1,2,3,4]',hasDuplicate([1,2,3,4]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1,2,3,3] True\n[1,2,3,4] False\n```\n:::\n:::\n\n\n## Alternative Solution - Array as Hash Table Approach\n\nIf the input array is mutable, all numbers are positive, and the numbers are within the array's length i.e. $(0 to n-1)$ inclusive, then we can use the array indices as a hash function (each index corresponds to a unique value or element within the range) with the sign of each element in the array as a marker (i.e. as a visited marker array, if negated, marks that we have previously visited this value). This eliminates the need for additional space i.e. this is an in-place solution.\n\n::: {#d8108ce0 .cell execution_count=5}\n``` {.python .cell-code}\ndef hasDuplicate(nums: list[int]) -> bool:\n    n = len(nums)\n    for i in range(n):\n        index = abs(nums[i])  # get the index of the item - abs() as duplicates may already be negated\n        if index >= n:        # skip if the index is out of range\n            continue\n        if nums[index] < 0:   # duplicate found if already negative\n            return True\n        nums[index] = -nums[index]  # mark as seen i.e. make negative\n    return False\n\n\nprint('[1,2,3,3]',hasDuplicate([1,2,3,3]))\nprint('[1,2,3,4]',hasDuplicate([1,2,3,4]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1,2,3,3] True\n[1,2,3,4] False\n```\n:::\n:::\n\n\n## Visualising the Array-as-Hash-Table Approach\n\nGiven input ``nums = [2, 3, 1, 2]``\n\n### Initial State\n```\nIndex:     0   1   2   3\nnums:      2   3   1   2\n```\n\n1. i = 0, nums[0] = 2:\n   ```\n   - abs(nums[0]) = 2 as our index\n   - check nums[2] = 1 (positive)\n   - negate nums[2] to mark we've seen 2\n   \n   Index:     0   1   2   3\n   nums:      2   3  -1   2\n   ```\n\n2. i = 1, nums[1] = 3:\n   ```\n   - abs(nums[1]) = 3 as our index\n   - check nums[3] = 2 (positive)\n   - negate nums[3] to mark we've seen 3\n   \n   Index:     0   1   2   3\n   nums:      2   3  -1  -2\n   ```\n\n3. i = 2, nums[2] = -1:\n   ```\n   - abs(nums[2]) = 1 as our index\n   - check nums[1] = 3 (positive)\n   - negate nums[1] to mark we've seen 1\n   \n   Index:     0   1   2   3\n   nums:      2  -3  -1  -2\n   ```\n\n4. i = 3, nums[3] = -2:\n   ```\n   - abs(nums[3]) = 2 as our index\n   - check nums[2] = -1 (negative)\n   - since nums[2] is negative, return True as we have a duplicate\n   \n   Index:     0   1   2   3\n   nums:      2  -3  -1  -2\n   ```\n\n- When we encounter a number ``n``, we use its absolute value as an index and negate the value at that index.  \n- If we later find that value at ``index = abs(n)`` is already negative, it means we've seen this number before.  \n- This approach cleverly uses the array itself as its own hash table, with the sign bit serving as our presence marker.  \n\n\n# References\n\n[1] [Neetcode Contains Duplicate](https://neetcode.io/problems/duplicate-integer)\n\n",
    "supporting": [
      "2024-12-17-duplicate-items_files"
    ],
    "filters": [],
    "includes": {}
  }
}