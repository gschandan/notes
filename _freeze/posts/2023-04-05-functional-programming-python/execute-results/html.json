{
  "hash": "401a1bb44615688166641bc419bfed43",
  "result": {
    "markdown": "---\ntitle: Introduction to Functional Programming In Python\ncategories:\n  - programming\n  - functional-programming\n  - introduction\n  - python\ndate: '2023-04-05'\ndescription: Notes about functional programming in python\nlayout: post\ntoc: true\nformat:\n  html:\n    html-math-method: katex\n    code-fold: false\n---\n\n# Functional Programming in Python\n\n## Basic Syntax\n\nPython functions can take functions as arguments and can return functions to their calling site.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\ndef inside():\n    print(\"This is inside\")\n\ndef outside(function):\n    function()\noutside(inside)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThis is inside\n```\n:::\n:::\n\n\nInner functions can sometimes be referred to as callbacks as they are not invoked immediately. Forexample, passing a custom function to `sorted()`:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nfruits = [\"apple\", \"tomato\", \"pear\", \"blueberry\"]\n\ndef reverse_length(x):\n    return -len(x)\n\nprint(sorted(fruits, key=reverse_length))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['blueberry', 'tomato', 'apple', 'pear']\n```\n:::\n:::\n\n\nFunctions can also return functions, which can be called without intermediate assignement:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndef inside():\n    print(\"This is inside\")\n\ndef outside(function):\n    return function\noutside(inside)()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThis is inside\n```\n:::\n:::\n\n\nLambda expressions can be useful and take the following form:\n```{code-fold=\"false\"}\nlambda <parameter_list (optional)>: <expression>\n```\nLambda expressions have their own namespace, and can access but not modify global variables.\nFor example:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nreverse = lambda x: x[::-1]\ncallable(reverse)\nprint(reverse(\"Hello World!\"))\nprint(reverse([1,2,3,4]))\n\nprint((lambda x1, x2: x1+x2)(2,2))\n\nmeaning_of_life = lambda: 42\nprint(meaning_of_life())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n!dlroW olleH\n[4, 3, 2, 1]\n4\n42\n```\n:::\n:::\n\n\nThe return value of a lambda can only be a single expression, and not assignemnet or return statements, or other control constructs. It also does not allow implicit tuple unpacking.\nTuples, lists and dictionaries can still be returned, but reqiore explicit parentheses:\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nprint((lambda x: (x, x**2, x**3))(2))\nprint((lambda x: [x, x**2, x**3])(2))\nprint((lambda x: {1:x, 2:x**2, 3:x**3})(2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(2, 4, 8)\n[2, 4, 8]\n{1: 2, 2: 4, 3: 8}\n```\n:::\n:::\n\n\n## Map\n\nMap can apply a function to each element of an iterable, and can return an iterator which can yield the results. Map takes the following form\n```{code-fold=\"false\"}\nmap(<function>, <iterable>)\n```\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nsquare = lambda x: x**2\nnumbers = [1,2,3,4,5,6,7]\niterable = map(square, numbers)\nprint(next(iterable))\nprint(next(iterable))\nprint(next(iterable))\nprint(list(iterable))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n4\n9\n[16, 25, 36, 49]\n```\n:::\n:::\n\n\nIterating over the iterable yeilds the items.\n\nMap can also take the form `map(<function>, <iterable$_1$>)`\n\n\n\n\n\n# References\n\n[^1]  https://realpython.com/python-functional-programming/\n\n",
    "supporting": [
      "2023-04-05-functional-programming-python_files"
    ],
    "filters": [],
    "includes": {}
  }
}