{
  "hash": "6dd8114a1a1b71f09bf824f1ffd90522",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ncategories:\n  - DSA\n  - data-structures\n  - introduction\n  - algorithms\n  - python\n  - binary-tree\ndate: '2024-09-01'\ndescription: Binary Tree Inversion\nlayout: post\ntitle: Inverting a Binary Tree\ntoc: true\nformat:\n  html:\n    html-math-method: katex\n---\n\n# Inverting a Binary Tree\n\n## Intuition\n\nThe intuition for inverting a binary tree is to swap the left and right children of each node recursively or iteratively. \nWe can visualize this as flipping the tree horizontally, where each node's left child becomes its right child and vice versa.\nThe key part for me, which may seem obvious, was realising that a binary tree is a data structure where each node has at most two child nodes.\n\n## Recursive Approach\n  \nInitially solved with a recursive approach based on the above intuition:  \n1. Start with the root node and define the base cases.  \n   1. If the root is None (empty tree), return None.  \n   2. If the root does not have 2 children, it is a leaf node -> return the root as is.  \n2. For non-leaf nodes, recursively invert the left and right subtrees.  \n3. Swap the inverted left and right subtrees.  \n4. Return the root of the inverted tree.  \n\n## Complexity  \n  \n- Time complexity: $O(n)$  \n  We visit each node in the tree exactly once, where $n$ is the number of nodes in the tree. Therefore, the time complexity is linear.  \n\n- Space complexity: $O(h)$  \n  The space complexity is $O(h)$, where h is the height of the tree. This is due to the recursive call stack. \n  In the worst case (a completely unbalanced tree), this could be $O(n)$, but for a balanced tree, it would be $O(\\log n)$.  \n\n## Code\n\n::: {#e8d5ac65 .cell execution_count=1}\n``` {.python .cell-code}\nfrom typing import Optional\n\nclass TreeNode:\n    def __init__(self, val: int=0, left: int|None = None, right: int|None =None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def invert_tree_recursive(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        \n        if not root:\n            return None\n        if not root.right and not root.left:\n            return root\n        \n        root.left, root.right = self.invert_tree_recursive(root.right), self.invert_tree_recursive(root.left)\n        return root\n\ndef print_tree(node: TreeNode, level: int=0, prefix: str=\"Root: \"):\n    if node is not None:\n        print(\" \" * (level * 4) + prefix + str(node.val))\n        if node.left or node.right:\n            print_tree(node.left, level + 1, \"L--- \")\n            print_tree(node.right, level + 1, \"R--- \")\n\nroot = TreeNode(4)\nroot.left = TreeNode(2)\nroot.right = TreeNode(7)\nroot.left.left = TreeNode(1)\nroot.left.right = TreeNode(3)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(9)\n\nprint(\"Original Tree:\")\nprint_tree(root)\n\nsolution = Solution()\ninverted_root = solution.invert_tree_recursive(root)\n\n\nprint(\"\\nInverted Tree:\")\nprint_tree(inverted_root)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOriginal Tree:\nRoot: 4\n    L--- 2\n        L--- 1\n        R--- 3\n    R--- 7\n        L--- 6\n        R--- 9\n\nInverted Tree:\nRoot: 4\n    L--- 7\n        L--- 9\n        R--- 6\n    R--- 2\n        L--- 3\n        R--- 1\n```\n:::\n:::\n\n\n## Iterative Approach\n  \nFor an interative appraoch, a stack or queue works nicely as we can do the following:   \n1. Start with the root node and push it onto the stack   \n2. Take a node from the stack  \n3. Swap the left and right children    \n4. Add the non-None children to the stack for processing  \n\n## Complexity\n  \n- Time complexity: $O(n)$  \n  We visit each node in the tree exactly once, where $n$ is the number of nodes in the tree, performing a constant time operation (swapping the nodes), and the while loop runs $n$ times. Therefore, the time complexity is linear.  \n  \n- Space complexity: $O(n)$   \n  - This occurs in a \"perfect\" binary tree, where the last level is completely full.  \n  - At its maximum, the queue could contain all the leaf nodes, which in a perfect binary tree is $(n+1)/2$ nodes (slightly more than half of all nodes).  \n  - For a balanced tree, it could be $O(w)$, where $w$ is the maximum width of the tree (which is typically $O(\\log n)$ for a balanced tree).\n  - For a skewed tree (e.g. a linked list), it would be $O(1)$ as we'd only ever have one node in the queue at a time. \n\n## Code\n\n::: {#07904ac8 .cell execution_count=2}\n``` {.python .cell-code}\nfrom typing import Optional\n\nclass TreeNode:\n    def __init__(self, val: int=0, left: int|None = None, right: int|None =None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def invert_tree_iterative(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root:\n            return None\n        \n        nodes_to_process = [root]\n        while nodes_to_process:\n            current = nodes_to_process.pop(0)\n            current.left, current.right = current.right, current.left\n            if current.left:\n                nodes_to_process.append(current.left)\n            if current.right:\n                nodes_to_process.append(current.right)\n        \n        return root\n\ndef print_tree(node: TreeNode, level: int=0, prefix: str=\"Root: \"):\n    if node is not None:\n        print(\" \" * (level * 4) + prefix + str(node.val))\n        if node.left or node.right:\n            print_tree(node.left, level + 1, \"L--- \")\n            print_tree(node.right, level + 1, \"R--- \")\n\nroot = TreeNode(4)\nroot.left = TreeNode(2)\nroot.right = TreeNode(7)\nroot.left.left = TreeNode(1)\nroot.left.right = TreeNode(3)\nroot.right.left = TreeNode(6)\nroot.right.right = TreeNode(9)\n\nprint(\"Original Tree:\")\nprint_tree(root)\n\nsolution = Solution()\ninverted_root = solution.invert_tree_iterative(root)\n\n\nprint(\"\\nInverted Tree:\")\nprint_tree(inverted_root)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOriginal Tree:\nRoot: 4\n    L--- 2\n        L--- 1\n        R--- 3\n    R--- 7\n        L--- 6\n        R--- 9\n\nInverted Tree:\nRoot: 4\n    L--- 7\n        L--- 9\n        R--- 6\n    R--- 2\n        L--- 3\n        R--- 1\n```\n:::\n:::\n\n\n## References\n\n[^1] [LeetCode 226 Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/description/)\n\n",
    "supporting": [
      "2024-09-01-binary-tree-inversion_files"
    ],
    "filters": [],
    "includes": {}
  }
}