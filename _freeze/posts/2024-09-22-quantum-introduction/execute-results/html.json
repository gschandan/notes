{
  "hash": "e9293a51c170dbd230664f40378d1571",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ncategories:\n  - programming\n  - quantum\n  - introduction\n  - maths\ndate: '2024-09-22'\ndescription: Quantum Programming Concepts Introduction\nlayout: post\ntitle: Introduction to Quantum Programming\ntoc: true\nformat:\n  html:\n    html-math-method: katex\n---\n\n# Introduction\n\nIn classical computing, we typically deal with systems that can exist in two states, i.e., bits are either 1 or 0. In quantum computing, we deal with systems that can exist in multiple states simultaneously (using the [Copenhagen interpretation](https://en.wikipedia.org/wiki/Copenhagen_interpretation)).\n\n## Quantum States\n\n### Quantum Bits (Qubits)\n\nWhile a classical bit is always in a definite state of either 0 or 1, a qubit can exist in a superposition of states:\n  \n1. **Superposition**: A qubit can be in a superposition of the basis states $|0\\rangle$ and $|1\\rangle$. This means it's not just 0 or 1, but a complex <ins>linear</ins> combination of both.  \n\n2. **Probability Distribution vs. Specific State**: A qubit has a probability distribution over possible measurement outcomes, rather than a probability of being in a specific state. Before measurement, the qubit exists in superposition.  \n\n3. **State Vector**: The state of a qubit is represented by a two-dimensional complex vector called a state vector. This vector contains the amplitudes for each basis state.  \n\n4. **Measurement**: When we measure a qubit, we force it to collapse into one of the basis states (typically $|0\\rangle$ or $|1\\rangle$). The probability of each outcome is determined by the squared magnitude of the corresponding amplitude in the state vector.  \n\n### Mathematical Representation\n\nA qubit's state is typically represented as:\n\n$$\n|\\psi\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle\n$$\n\nWhere:  \n- $|\\psi\\rangle$ represents the qubit's state  \n- $\\alpha$ and $\\beta$ are complex numbers called probability amplitudes  \n- $|\\alpha|^2 + |\\beta|^2 = 1$ (normalization condition) \n   \n\nA state vector is a mathematical representation of a qubit's state in quantum mechanics. \nFor a single qubit, it's a two-dimensional complex vector that captures all the information about the qubit's state.\n\n#### Amplitudes\n\nAmplitudes ($\\alpha$ and $\\beta$) are complex numbers that determine the quantum state's properties.\n\n1. **Probability**: The squared magnitude of an amplitude ($|\\alpha|^2$ or $|\\beta|^2$) gives the probability of measuring the qubit in the corresponding basis state.\n\n2. **Phase**: The complex phase of the amplitude carries information about the qubit's behavior in interference situations.\n\n3. **Superposition**: Non-zero amplitudes for both $|0\\rangle$ and $|1\\rangle$ indicate the qubit is in a superposition of these basis states.\n\n#### Example 1: Classical-like States\n\n1. $|\\psi\\rangle = 1|0\\rangle + 0|1\\rangle$\n   - This represents a qubit in the definite state $|0\\rangle$.\n   - Measuring this qubit will always yield $|0\\rangle$.\n\n2. $|\\psi\\rangle = 0|0\\rangle + 1|1\\rangle$\n   - This represents a qubit in the definite state $|1\\rangle$.\n   - Measuring this qubit will always yield $|1\\rangle$.\n\n#### Example 2: Equal Superposition\n\n$$|\\psi\\rangle = \\frac{1}{\\sqrt{2}}|0\\rangle + \\frac{1}{\\sqrt{2}}|1\\rangle$$\n\n- This is often written as $|+\\rangle$ and represents an equal superposition.\n- Probability of measuring $|0\\rangle$: $|\\frac{1}{\\sqrt{2}}|^2 = \\frac{1}{2}$\n- Probability of measuring $|1\\rangle$: $|\\frac{1}{\\sqrt{2}}|^2 = \\frac{1}{2}$\n- The qubit has an equal chance of being measured in either state.\n\n#### Example 3: Unequal Superposition\n\n$$|\\psi\\rangle = \\frac{\\sqrt{3}}{2}|0\\rangle + \\frac{1}{2}|1\\rangle$$\n\n- Probability of measuring $|0\\rangle$: $|\\frac{\\sqrt{3}}{2}|^2 = \\frac{3}{4}$\n- Probability of measuring $|1\\rangle$: $|\\frac{1}{2}|^2 = \\frac{1}{4}$\n- The qubit is more likely to be measured in state $|0\\rangle$.\n\n#### Example 4: Complex Amplitudes\n\n$$|\\psi\\rangle = \\frac{1}{\\sqrt{2}}|0\\rangle + \\frac{i}{\\sqrt{2}}|1\\rangle$$\n\n- Probability of measuring $|0\\rangle$: $|\\frac{1}{\\sqrt{2}}|^2 = \\frac{1}{2}$\n- Probability of measuring $|1\\rangle$: $|\\frac{i}{\\sqrt{2}}|^2 = \\frac{1}{2}$\n- Equal probabilities, but the $i$ in the second amplitude introduces a phase difference.\n- This phase difference is important in quantum interference but doesn't affect single-qubit measurements.\n\n### Multi-Qubit Systems\n\nFor systems with multiple qubits, the state vector grows exponentially:\n\n- 1 qubit: 2-dimensional vector\n- 2 qubits: 4-dimensional vector\n- 3 qubits: 8-dimensional vector\n- n qubits: $2^n$ dimensional vector\n\nThis exponential growth in the state space is what gives quantum computers their potential power relative to classical computers.  \n\n### Bloch Sphere Representation\n\nQubits are often visualized using the Bloch sphere, a unit sphere in three-dimensional space. Any single qubit state can be represented as a point on the surface of this sphere.\n\n::: {#1952d5a8 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom qutip import Bloch, basis, sigmax, sigmay, sigmaz\n\ndef plot_bloch_sphere(states, labels):\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='3d')\n    b = Bloch(axes=ax)\n    b.point_color = ['r', 'g', 'b', 'y']\n    \n    for state, label in zip(states, labels):\n        b.add_states(state)\n        b.add_annotation(state, label)\n    \n    b.render()\n    return fig\n\n# some example states\npsi1 = basis(2, 0)  # |0⟩ i.e. classical 0\npsi2 = basis(2, 1)  # |1⟩ i.e. classical 1\npsi3 = (basis(2, 0) + basis(2, 1)).unit()  # (|0⟩ + |1⟩)/√2 i.e. equal superposition\npsi4 = (basis(2, 0) + 1j*basis(2, 1)).unit()  # (|0⟩ + i|1⟩)/√2 i.e. superposition with a phase difference\n\nstates = [psi1, psi2, psi3, psi4]\nlabels = [\"|0⟩\", \"|1⟩\", \"|+⟩\", \"|+i⟩\"]\n\nfig = plot_bloch_sphere(states, labels)\n\nplt.tight_layout()\nplt.savefig('bloch_sphere_example.png', dpi=150, bbox_inches='tight')\nplt.close(fig)\n```\n:::\n\n\n![Example Bloch Sphere representing quantum states](bloch_sphere_example.png)\n\n- The $|0\\rangle$ state is represented by a point at the north pole of the sphere.  \n- The $|1\\rangle$ state is represented by a point at the south pole of the sphere.  \n- The $|+\\rangle$ state (equal superposition) is represented by a point on the equator along the x-axis.  \n- The $|+i\\rangle$ state is represented by a point on the equator along the y-axis.  \n\n###  Visualizing State Evolution\n\nWe can also use this to visualize how quantum states evolve under certain operations. Here's an example that shows the state evolution under the action of a Hadamard-like gate:\n\n::: {#a6a75f76 .cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom qutip import Bloch, basis, qeye, sigmax, sigmay, sigmaz\nfrom matplotlib.animation import FuncAnimation\nimport imageio\n\ndef plot_bloch_sphere(states, filename='bloch_sphere_evolution.gif', duration=0.1):\n    fig = plt.figure(figsize=(8, 8))\n    ax = fig.add_subplot(111, projection='3d')\n    b = Bloch(axes=ax)\n\n    def update(frame):\n        ax.cla()\n        b = Bloch(axes=ax)\n        b.add_states(states[frame])\n        b.add_states([states[0], states[-1]], 'point')\n        b.render()\n        ax.set_title(f'Frame {frame + 1}/{len(states)}')\n\n    anim = FuncAnimation(fig, update, frames=len(states), repeat=True)\n\n    frames = []\n    for i in range(len(states)):\n        update(i)\n        fig.canvas.draw()\n        image = np.frombuffer(fig.canvas.tostring_rgb(), dtype='uint8')\n        image = image.reshape(fig.canvas.get_width_height()[::-1] + (3,))\n        frames.append(image)\n\n    imageio.mimsave(filename, frames, duration=duration)\n    plt.close(fig)\n\ndef state_evolution(initial_state, operation, steps=50):\n    states = [initial_state]\n    for i in range(1, steps+1):\n        states.append(operation(initial_state, i/steps))\n    return states\n\ndef hadamard_like_transform(state, t):\n    H = np.sqrt(1 - t) * sigmaz() + np.sqrt(t) * sigmax()\n    return (1 - t) * state + t * H * state\n\npsi0 = basis(2, 0) # initial state |0⟩\n\nstates = state_evolution(psi0, hadamard_like_transform, steps=50)\n\nplot_bloch_sphere(states, 'bloch_sphere_evolution.gif', duration=0.1)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/tmp/ipykernel_572339/1348161396.py:26: MatplotlibDeprecationWarning: The tostring_rgb function was deprecated in Matplotlib 3.8 and will be removed in 3.10. Use buffer_rgba instead.\n  image = np.frombuffer(fig.canvas.tostring_rgb(), dtype='uint8')\n```\n:::\n:::\n\n\n![Example Bloch Sphere representing quantum state evolution](bloch_sphere_evolution.gif)\n\nThis will show how the $|0\\rangle$ state evolves into the $|+\\rangle$ state under the action of the Hadamard-like gate.\n\n### Are States Typically Between 0 and 1?\n  \n1. The basis states are typically labeled $|0\\rangle$ and $|1\\rangle$, which might suggest values between 0 and 1.  \n2. However, the actual state of a qubit is described by complex amplitudes $\\alpha$ and $\\beta$. These amplitudes can take any complex values as long as $|\\alpha|^2 + |\\beta|^2 = 1$.  \n3. The probabilities of measuring $|0\\rangle$ or $|1\\rangle$ (given by $|\\alpha|^2$ and $|\\beta|^2$ respectively) are between 0 and 1 (as they must be for any probability).  \n\n### Example\n\nWith a qubit in the state:\n\n$$\n|\\psi\\rangle = \\frac{1}{\\sqrt{2}}|0\\rangle + \\frac{1}{\\sqrt{2}}|1\\rangle\n$$\n\nThis state has an equal probability of being measured as $|0\\rangle$ or $|1\\rangle$. The probabilities are:\n\n- $P(|0\\rangle) = |\\frac{1}{\\sqrt{2}}|^2 = \\frac{1}{2}$\n- $P(|1\\rangle) = |\\frac{1}{\\sqrt{2}}|^2 = \\frac{1}{2}$\n\n## Probability Vectors\n\nProbability vectors are fundamental in describing quantum states. They represent the probability distribution of possible outcomes when measuring a quantum system.\n\n### Properties:\n\n1. All entries are non-negative real numbers.\n2. The sum of all entries equals 1.\n\n### Example:\n\nFor a coin flip:\n```\np = [0.5, 0.5]  # Represents a fair coin (50% chance of heads, 50% chance of tails)\n```\n\n## Linear Combinations and Convex Combinations\n\nIn quantum mechanics, states can be combined linearly, but probability vectors specifically use convex combinations.\n\n### Convex Combination:\n\nA linear combination where:\n1. All coefficients are non-negative.\n2. The sum of coefficients equals 1.\n\nThis ensures that the result is still a valid probability vector.\n\n### Example:\n\n```python\np1 = [0.3, 0.7]\np2 = [0.6, 0.4]\nα = 0.4\n\nconvex_combination = α * np.array(p1) + (1 - α) * np.array(p2)\n# Result: [0.48, 0.52]\n```\n\n## Classical Transformations\n\nClassical transformations in quantum computing are represented by matrices that transform one probability vector into another.\n\n### Properties of Valid Classical Transformation Matrices:\n\n1. All entries are non-negative.\n2. The sum of each column is 1 (stochastic property).\n\n### Example: NOT Operation\n\nThe NOT operation flips a bit. In matrix form for a single qubit:\n\n$$\n\\text{NOT} = \\begin{bmatrix}\n0 & 1 \\\\\n1 & 0\n\\end{bmatrix}\n$$\n\n## Tensor Product\n\nThe tensor product is used to combine quantum systems, creating a joint state space.\n\n### Properties:\n\n- Combines probability vectors of individual systems.\n- Results in a higher-dimensional probability vector.\n\n### Example:\n\nFor two coins:\n```python\ncoin1 = [0.5, 0.5]  # Fair coin\ncoin2 = [0.7, 0.3]  # Biased coin\n\njoint_state = np.kron(coin1, coin2)\n# Result: [0.35, 0.15, 0.35, 0.15]\n```\n\nNote: Not all higher-dimensional probability vectors can be decomposed into tensor products of lower-dimensional vectors.\n\n## Quantum Circuits\n\nQuantum circuits are sequences of operations (gates) applied to qubits. They are the quantum analogue of classical logic circuits.\n\n### Example: Simple Quantum Circuit\n\n```\n      ┌───┐\nq_0: ─┤ H ├─────●─────\n      └───┘     │\nq_1: ───────────┼─────\n                │\nq_2: ───────────X─────\n```\n\nThis circuit applies a Hadamard gate (H) to the first qubit and then a controlled-NOT (CNOT) with the first qubit as control and the third as target.\n3. **$\\alpha$ and $\\beta$**:\n   - These are complex numbers called probability amplitudes.\n   - $|\\alpha|^2$ gives the probability of measuring the qubit in state $|0\\rangle$.\n   - $|\\beta|^2$ gives the probability of measuring the qubit in state $|1\\rangle$.\n   - The normalization condition requires that $|\\alpha|^2 + |\\beta|^2 = 1$.\n\n### Vector Notation\n\nIn vector notation, the same state can be written as:\n\n$$|\\psi\\rangle = \\begin{bmatrix} \\alpha \\\\ \\beta \\end{bmatrix}$$\n\n### Dirac (Bra-Ket) Notation\n  \n1. **Ket $|\\psi\\rangle$**: Represents a column vector.  \n2. **Bra $\\langle\\psi|$**: Represents the conjugate transpose of $|\\psi\\rangle$, i.e., a row vector.  \n   - Conjugate Transpose (or Hermitian Conjugate): formed from an m-by-n matrix by taking the transpose of the matrix (forming an n-by-m matrix), then taking the complex conjugate of each entry (negating their imaginary components).  \n\n### Complex Numbers and Polar Form\n\nSince $\\alpha$ and $\\beta$ are complex numbers, they can be written in polar form:\n\n$$\\begin{align*}\n\\alpha &= r_1e^{i\\theta_1} \\\\\n\\beta &= r_2e^{i\\theta_2}\n\\end{align*}$$\n\nWhere:\n- $r_1$ and $r_2$ are the magnitudes ($r_1^2 + r_2^2 = 1$)\n- $\\theta_1$ and $\\theta_2$ are the phases\n- $i$ is the imaginary unit ($i^2 = -1$)\n\n### Density Matrix\n\nFor mixed states or when dealing with subsystems, we often use the density matrix representation:\n\n$$\\rho = |\\psi\\rangle\\langle\\psi| = \\begin{bmatrix} \n|\\alpha|^2 & \\alpha\\beta^* \\\\\n\\alpha^*\\beta & |\\beta|^2\n\\end{bmatrix}$$\n\nWhere $*$ denotes complex conjugation.\n\n### Examples with Mathematical Representation\n\n1. **$|0\\rangle$ state**:\n   $|\\psi\\rangle = 1|0\\rangle + 0|1\\rangle = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$\n\n2. **$|1\\rangle$ state**:\n   $|\\psi\\rangle = 0|0\\rangle + 1|1\\rangle = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$\n\n3. **$|+\\rangle$ state** (equal superposition):\n   $|\\psi\\rangle = \\frac{1}{\\sqrt{2}}|0\\rangle + \\frac{1}{\\sqrt{2}}|1\\rangle = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$\n\n4. **$|-\\rangle$ state**:\n   $|\\psi\\rangle = \\frac{1}{\\sqrt{2}}|0\\rangle - \\frac{1}{\\sqrt{2}}|1\\rangle = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 \\\\ -1 \\end{bmatrix}$\n\n5. **$|+i\\rangle$ state**:\n   $|\\psi\\rangle = \\frac{1}{\\sqrt{2}}|0\\rangle + \\frac{i}{\\sqrt{2}}|1\\rangle = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 \\\\ i \\end{bmatrix}$\n\n### Bloch Sphere Coordinates\n\nThe Bloch sphere provides a geometrical representation of a qubit's state. Any pure state of a qubit can be represented as:\n\n$$|\\psi\\rangle = \\cos\\left(\\frac{\\theta}{2}\\right)|0\\rangle + e^{i\\phi}\\sin\\left(\\frac{\\theta}{2}\\right)|1\\rangle$$\n\nWhere:\n- $\\theta$ (theta) is the polar angle ($0 \\leq \\theta \\leq \\pi$)\n- $\\phi$ (phi) is the azimuthal angle ($0 \\leq \\phi < 2\\pi$)\n\nThis representation directly maps to the surface of the Bloch sphere.\n\n### Multi-Qubit Systems\n\nFor a system of n qubits, the state is represented by a $2^n$ dimensional complex vector. For example, a two-qubit system has the general form:\n\n$$|\\psi\\rangle = \\alpha|00\\rangle + \\beta|01\\rangle + \\gamma|10\\rangle + \\delta|11\\rangle$$\n\nWhere $\\alpha$, $\\beta$, $\\gamma$, and $\\delta$ are complex amplitudes satisfying $|\\alpha|^2 + |\\beta|^2 + |\\gamma|^2 + |\\delta|^2 = 1$.\n\n## References\n   \n1. [QWorld](https://qworld.net/qbook101/)  \n2. [Dirac Bra-Ket Notation](https://glenmartin.wordpress.com/dirac-bra-ket-notation/#:~:text=If%20%CE%A8%20corresponds%20to%20a,bra%E2%80%9D%20vector%20%3C%CE%A8%7C.)\n3. Mermin, N. D. (2007). Quantum Computer Science: An Introduction. Cambridge University Press.\n4. Sutor, R. S. (2019). Dancing with Qubits: How quantum computing works and how it can change the world. Packt Publishing.\n5. Griffiths, D. J., & Schroeter, D. F. (2018). Introduction to Quantum Mechanics (3rd ed.). Cambridge University Press.  \n6. Preskill, J. (2018). Quantum Computing in the NISQ era and beyond. Quantum, 2, 79.\n\n",
    "supporting": [
      "2024-09-22-quantum-introduction_files"
    ],
    "filters": [],
    "includes": {}
  }
}