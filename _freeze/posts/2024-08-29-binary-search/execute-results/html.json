{
  "hash": "5a3a51246dfb4329b217fee295498912",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ncategories:\n  - DSA\n  - data-structures\n  - introduction\n  - algorithms\n  - python\ndate: '2024-08-29'\ndescription: Binary Search Introduction\nlayout: post\ntitle: Introduction to Binary Search\ntoc: true\nformat:\n  html:\n    html-math-method: katex\n    theme:\n      light:\n        - flatly\n        - light.scss\n      dark:\n        - darkly\n        - dark.scss\n---\n\n## Binary Search\n\nBinary search is an efficienct way to find items in a **sorted** or ordered collection, by repeatedly dividing the range to search in half, as we know, due to the ordering, if the value is to the left or right of the current item.\n\n### Algorithm\n  \n1. Pick an item in the middle of the array  \n2. If the item is equal to the item being searched for, the search ends  \n3. If the target is less than the middle elements, repeat the steps in the lower half/left hand side   \n4. If the target is greater, repeat the steps in the upper half/right hand side  \n\n```\n// Sorted array\n[1, 3, 4, 6, 8, 9, 11] \n ^           ^      ^\nlow         mid    high\n\nTarget: 6\nStep 1: mid = 8, target < mid, search lower half\n[1, 3, 4, 6]\n ^     ^  ^\nlow   mid high\n\nStep 2: mid = 3, target > mid, search upper half\n      [4, 6]\n       ^  ^\n      low high\n      mid\n\nStep 3: mid = 6, target == mid, found!\n```\n\n### Implementation\n\n::: {#4c49e0a5 .cell execution_count=1}\n``` {.python .cell-code}\ndef binary_search_iterative(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef binary_search_recursive(arr, target):\n    # TODO\n    pass\n\nsorted_array = [1, 3, 4, 6, 8, 9, 11]\ntarget = 6\nresult = binary_search_iterative(sorted_array, target)\nprint(f\"Target {target} found at index: {result}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTarget 6 found at index: 3\n```\n:::\n:::\n\n\n### Time Complexity\n  \n- $O(\\log n)$  \n- $\\Omega(1)$ (when the middle element is the target)  \n\n### Space Complexity\n  \n- Iterative implementation: $O(1)$  \n- Recursive implementation: $O(\\log n)$ due to the call stack  \n\n### Advantages\n  \n1. Very efficient for searching in large sorted datasets  \n2. Logarithmic time complexity makes it much faster than linear search for large arrays  \n\n::: {#f98748a2 .cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport time\nimport random\n\ndef linear_search(arr, target):\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i\n    return -1\n\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef measure_search_time(search_func, arr, target):\n    start_time = time.time()\n    search_func(arr, target)\n    end_time = time.time()\n    return end_time - start_time\n\ndef create_plot(sizes, linear_times, binary_times):\n    plt.figure(figsize=(12, 6))\n    plt.plot(sizes, linear_times, label='Linear Search', color='red', marker='o')\n    plt.plot(sizes, binary_times, label='Binary Search', color='green', marker='o')\n    plt.title('Binary Search vs Linear Search Performance')\n    plt.xlabel('Input Size (n)')\n    plt.ylabel('Execution Time (seconds)')\n    plt.legend()\n    plt.xscale('log')\n    plt.yscale('log')\n    plt.grid(True, linestyle='--', alpha=0.7)\n    plt.tight_layout()\n    return plt\n\nsizes = np.logspace(1, 6, num=20, dtype=int)\nlinear_times = []\nbinary_times = []\n\nfor size in sizes:\n    arr = sorted(random.sample(range(size * 10), size))\n    target = random.choice(arr)\n    linear_time = measure_search_time(linear_search, arr, target)\n    binary_time = measure_search_time(binary_search, arr, target)\n    linear_times.append(linear_time)\n    binary_times.append(binary_time)\n\nplot = create_plot(sizes, linear_times, binary_times)\nplot.savefig('search_performance.png')\nplt.close()\n\nprint(f\"Largest input size: {sizes[-1]}\")\nprint(f\"Linear search time for largest input: {linear_times[-1]:.6f} seconds\")\nprint(f\"Binary search time for largest input: {binary_times[-1]:.6f} seconds\")\nprint(f\"Difference for the largest input: {linear_times[-1] / binary_times[-1]:.2f}x\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLargest input size: 1000000\nLinear search time for largest input: 0.029848 seconds\nBinary search time for largest input: 0.000006 seconds\nDifference for the largest input: 5007.60x\n```\n:::\n:::\n\n\n![Binary Search vs Linear Search Performance](search_performance.png)\nAs you can see, the binary search (green line) remains much faster than the linear search (red line) as the input size grows, demonstrating its logarithmic time complexity compared to the linear time complexity of the linear search.\n\n### Disadvantages\n  \n1. Requires a sorted array  \n2. Not efficient for small datasets compared to linear search due to overhead  \n\n### Applications\n  \n- Used in algorithms for database searches and spell checkers  \n- Finding the closest element to a target value in a sorted array  \n  \n### Variants  \n  \n1. Uniform Binary Search  \n2. Exponential Search  \n3. Interpolation Search  \n\n## References\n\n[^1] [Khan Academy - Binary Search](https://www.khanacademy.org/computing/computer-science/algorithms/binary-search/a/binary-search)\n\n[^2] [LeetCode - Binary Search Problems](https://leetcode.com/tag/binary-search/)\n\n",
    "supporting": [
      "2024-08-29-binary-search_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}