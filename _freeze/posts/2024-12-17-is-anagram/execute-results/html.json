{
  "hash": "87646d6888e776adff74ac81acfad5b1",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Anagram\"\ndate: \"2024-12-17\"\ncategories: \n  - dsa\n  - algorithms\n  - data-structures\n  - basics\ndescription: \"Analysis of different ways to solve finding out if two input strings are anagrams\"\ntoc: true\nlayout: post\nformat:\n  html:\n    html-math-method: katex\njupyter: python3\n---\n\n\n# Valid Anagram\n\n## Problem Statement\n\nGiven two strings `s` and `t`, determine if they are anagrams of each other.\n\n### Examples\n\nExample 1:\n```\nInput: s = \"racecar\", t = \"carrace\"\nOutput: true\nExplanation: Both strings contain exactly the same characters: 'a', 'c', 'c', 'e', 'r', 'r'\n```\n\n### Constraints\n- Both strings consist only of lowercase English letters\n- The strings can be empty or have different lengths\n\n## Initial Solution - Sorting Approach\n\nThe most intuitive approach might be to sort both strings and compare them:\n\n::: {#fdbf46d6 .cell execution_count=1}\n``` {.python .cell-code}\ndef isAnagram(s: str, t: str) -> bool:\n\n    if len(s) != len(t):\n        return False\n\n    return sorted(s) == sorted(t)\n\nprint(\"Test 1:\", isAnagram(\"racecar\", \"carrace\"))\nprint(\"Test 2:\", isAnagram(\"jar\", \"jam\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTest 1: True\nTest 2: False\n```\n:::\n:::\n\n\n### Complexity Analysis\n\n1. Sorting each string:\n   - Python's default sorting algorithm (Timsort) has a time complexity of $O(n \\log n)$\n   - Where n is the length of the string\n\n2. String comparison (sorted(s) == sorted(t)):\n   - Requires comparing each character: $O(n)$\n   - But this is overshadowed by the sorting complexity\n\nOverall:  \n- Time Complexity: $O(n \\log n)$  \n- Space Complexity: $O(n)$ for creating new sorted strings\n\n## Optimised Solution - Character Count Approach\n\nWe can achieve better time complexity using a character frequency counter:\n\n::: {#0a92b6a8 .cell execution_count=2}\n``` {.python .cell-code}\ndef isAnagram(s: str, t: str) -> bool:\n    if len(s) != len(t):\n        return False\n    \n    char_count = [0] * 26\n    for i in range(len(s)):\n        char_count[ord(s[i]) - ord('a')] += 1\n        char_count[ord(t[i]) - ord('a')] -= 1\n    \n\n    return all(count == 0 for count in char_count)\n\nprint(\"Test 1:\", isAnagram(\"racecar\", \"carrace\")) \nprint(\"Test 2:\", isAnagram(\"jar\", \"jam\"))          \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTest 1: True\nTest 2: False\n```\n:::\n:::\n\n\n### Insights:\n\n1. An anagram must have exactly the same number of each character\n2. We only need to track 26 possible characters (lowercase letters)\n3. We can increment counts for one string and decrement for the other\n4. If the strings are anagrams, all final counts will be zero\n\n### Complexity Analysis\n\n1. Length comparison: $O(1)$\n2. Creating counter array: $O(1)$ (fixed size of 26)\n3. Counting characters: $O(n)$ where n is string length\n4. Checking final counts: $O(1)$ (always 26 comparisons)\n\nOverall:\n- Time Complexity: $O(n)$\n- Space Complexity: $O(1)$ (fixed size array)\n\nor alternatively:\n\n::: {#f6894660 .cell execution_count=3}\n``` {.python .cell-code}\nfrom collections import Counter\n\ndef isAnagram(s: str, t: str) -> bool:\n    counter_s = Counter(s)\n    counter_t = Counter(t)\n    return counter_s == counter_t\n\nprint(\"Test 1:\", isAnagram(\"racecar\", \"carrace\"))\nprint(\"Test 2:\", isAnagram(\"jar\", \"jam\"))              \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTest 1: True\nTest 2: False\n```\n:::\n:::\n\n\n### Complexity Analysis\n\nThe Counter approach has some key implementation details worth understanding:\n\n1. Counter Creation ($O(n)$):\n   - Each Counter() call iterates through its input string once\n   - Counter uses a hash table internally for frequency counting\n   - Each character insertion is amortised $O(1)$\n\n2. Counter Comparison ($O(n)$):\n   - Counter comparison checks if all elements and their frequencies match\n   - Must examine each unique character at least once\n\nOverall:  \n- Time Complexity: $O(n)$ where n is the length of the strings  \n- Space Complexity: $O(k)$ where k is the size of the character set (26 for lowercase letters)\n\n\n## Alternative Solution - Hash Map Approach\n\nFor cases where we might have a larger character set (not just lowercase letters), we can use a hash map:\n\n::: {#5899ad9b .cell execution_count=4}\n``` {.python .cell-code}\nfrom collections import defaultdict\n\ndef isAnagram(s: str, t: str) -> bool:\n    if len(s) != len(t):\n        return False\n    \n    char_count = defaultdict(int)\n    \n    for s_char, t_char in zip(s, t):\n        char_count[s_char] += 1\n        char_count[t_char] -= 1\n    \n    return all(count == 0 for count in char_count.values())\n\nprint(\"Test 1:\", isAnagram(\"racecar\", \"carrace\")) \nprint(\"Test 2:\", isAnagram(\"jar\", \"jam\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTest 1: True\nTest 2: False\n```\n:::\n:::\n\n\n### Complexity Analysis\n\n1. Dictionary operations (defaultdict):\n   - Each insertion/lookup is amortised $O(1)$\n   \n2. Space considerations:\n   - Grows with unique characters in input\n   - Still $O(k)$ where k is the size of the character set\n\nOverall:  \n- Time Complexity: $O(n)$  \n- Space Complexity: $O(k)$ where k is the character set size  \n\n## Performance Comparison\n\n| Approach | Time Complexity | Space Complexity | Best Used When |\n|----------|----------------|------------------|----------------|\n| Sorting | $O(n \\log n)$ | $O(n)$ | Simple solution needed |\n| Array Counter | $O(n)$ | $O(1)$ | Known small character set |\n| Hash Map | $O(n)$ | $O(k)$ | Large/unknown character set |\n\n## Takeaways\n\n1. The array counter approach is most efficient for this specific problem due to the constraint of lowercase letters only.\n2. The hash map approach is more flexible and can handle any character set.\n\n# References\n\n[1] [Valid Anagram](hhttps://neetcode.io/problems/is-anagram)  \n[2] [LeetCode Valid Anagram](https://leetcode.com/problems/valid-anagram/)\n\n",
    "supporting": [
      "2024-12-17-is-anagram_files"
    ],
    "filters": [],
    "includes": {}
  }
}