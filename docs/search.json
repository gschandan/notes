[
  {
    "objectID": "posts/2024-08-27-linked-lists.html",
    "href": "posts/2024-08-27-linked-lists.html",
    "title": "Introduction to Linked Lists",
    "section": "",
    "text": "A linked list is a linear data structure where elements are stored in nodes. Each node contains a data field and a reference (or link) to the next node in the sequence.\n\n\n[Data|Next] -&gt; [Data|Next] -&gt; [Data|Next] -&gt; null\n\n\n\n\nSingly Linked List\nDoubly Linked List\nCircular Linked List\n\n\n\n\nIn a singly linked list, each node points to the next node in the sequence. In the following examples, the dot (•) is a pointer to the relevant node:\nExample:\n[3|•] -&gt; [7|•] -&gt; [1|•] -&gt; [9|•] -&gt; [4|•] -&gt; null\nOperations: - Access: O(n) - Search: O(n) - Insertion at beginning: O(1) - Insertion at end: O(n) - Deletion at beginning: O(1) - Deletion at end: O(n)\n\n\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass SinglyLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        last = self.head\n        while last.next:\n            last = last.next\n        last.next = new_node\n    \n    def __str__(self):\n        if not self.head:\n            return \"empty\"\n        current = self.head\n        result = []\n        while current:\n            result.append(f\"[{current.data}|•]\")\n            current = current.next\n        result.append(\"null\")\n        return \" -&gt; \".join(result)\n\nsll = SinglyLinkedList()\nsll.append(3)\nsll.append(7)\nsll.append(1)\nsll.append(9)\nsll.append(4)\nprint(\"Singly Linked List:\", sll)\n\nSingly Linked List: [3|•] -&gt; [7|•] -&gt; [1|•] -&gt; [9|•] -&gt; [4|•] -&gt; null\n\n\n\n\n\n\nIn a doubly linked list, each node contains references to both the next and previous nodes.\nExample:\nnull &lt;-&gt; [3|•|•] &lt;-&gt; [7|•|•] &lt;-&gt; [1|•|•] &lt;-&gt; [9|•|•] &lt;-&gt; [4|•|•] &lt;-&gt; null\nOperations: - Access: O(n) - Search: O(n) - Insertion at beginning/end: O(1) - Deletion at beginning/end: O(1)\n\n\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        last = self.head\n        while last.next:\n            last = last.next\n        last.next = new_node\n        new_node.prev = last\n\n    def __str__(self):\n        if not self.head:\n            return \"empty\"\n        current = self.head\n        result = [\"null\"]\n        while current:\n            result.append(f\"[{current.data}|•|•]\")\n            current = current.next\n        result.append(\"null\")\n        return \" &lt;-&gt; \".join(result)\n\n\ndll = DoublyLinkedList()\ndll.append(3)\ndll.append(7)\ndll.append(1)\ndll.append(9)\ndll.append(4)\nprint(\"Doubly Linked List:\", dll)\n\nDoubly Linked List: null &lt;-&gt; [3|•|•] &lt;-&gt; [7|•|•] &lt;-&gt; [1|•|•] &lt;-&gt; [9|•|•] &lt;-&gt; [4|•|•] &lt;-&gt; null\n\n\n\n\n\n\nIn a circular linked list, the last node points back to the first node, forming a circle.\nExample (Singly Circular):\n    ┌────────────────────────────────┐\n    │                                ▼\n[3|•] -&gt; [7|•] -&gt; [1|•] -&gt; [9|•] -&gt; [4|•]\nOperations: - Similar to singly/doubly linked lists - No null end: facilitates continuous traversal\n\n\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass CircularLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            new_node.next = self.head\n            return\n        last = self.head\n        while last.next != self.head:\n            last = last.next\n        last.next = new_node\n        new_node.next = self.head\n\n    def __str__(self):\n        if not self.head:\n            return \"empty\"\n        current = self.head\n        result = []\n        while True:\n            result.append(f\"[{current.data}|•]\")\n            current = current.next\n            if current == self.head:\n                break\n        return \" -&gt; \".join(result) + \" (circular)\"\n\ncll = CircularLinkedList()\ncll.append(3)\ncll.append(7)\ncll.append(1)\ncll.append(9)\ncll.append(4)\nprint(\"Circular Linked List:\", cll)\n\nCircular Linked List: [3|•] -&gt; [7|•] -&gt; [1|•] -&gt; [9|•] -&gt; [4|•] (circular)\n\n\n\n\n\n\n\nDynamic size\nEase of insertion/deletion\nEfficient memory utilization\n\n\n\n\n\nRandom access is not allowed - must be traversed\nExtra memory space for pointers at each node\nNot cache friendly - less cache locality for CPU than a contiguous array - more likely to be randomly scattered around and therefore get cache misses\n\n\n\n\n\nImplementation of stacks and queues\n\nImplementing mutable arrays or collections"
  },
  {
    "objectID": "posts/2024-08-27-linked-lists.html#linked-lists",
    "href": "posts/2024-08-27-linked-lists.html#linked-lists",
    "title": "Introduction to Linked Lists",
    "section": "",
    "text": "A linked list is a linear data structure where elements are stored in nodes. Each node contains a data field and a reference (or link) to the next node in the sequence.\n\n\n[Data|Next] -&gt; [Data|Next] -&gt; [Data|Next] -&gt; null\n\n\n\n\nSingly Linked List\nDoubly Linked List\nCircular Linked List\n\n\n\n\nIn a singly linked list, each node points to the next node in the sequence. In the following examples, the dot (•) is a pointer to the relevant node:\nExample:\n[3|•] -&gt; [7|•] -&gt; [1|•] -&gt; [9|•] -&gt; [4|•] -&gt; null\nOperations: - Access: O(n) - Search: O(n) - Insertion at beginning: O(1) - Insertion at end: O(n) - Deletion at beginning: O(1) - Deletion at end: O(n)\n\n\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass SinglyLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        last = self.head\n        while last.next:\n            last = last.next\n        last.next = new_node\n    \n    def __str__(self):\n        if not self.head:\n            return \"empty\"\n        current = self.head\n        result = []\n        while current:\n            result.append(f\"[{current.data}|•]\")\n            current = current.next\n        result.append(\"null\")\n        return \" -&gt; \".join(result)\n\nsll = SinglyLinkedList()\nsll.append(3)\nsll.append(7)\nsll.append(1)\nsll.append(9)\nsll.append(4)\nprint(\"Singly Linked List:\", sll)\n\nSingly Linked List: [3|•] -&gt; [7|•] -&gt; [1|•] -&gt; [9|•] -&gt; [4|•] -&gt; null\n\n\n\n\n\n\nIn a doubly linked list, each node contains references to both the next and previous nodes.\nExample:\nnull &lt;-&gt; [3|•|•] &lt;-&gt; [7|•|•] &lt;-&gt; [1|•|•] &lt;-&gt; [9|•|•] &lt;-&gt; [4|•|•] &lt;-&gt; null\nOperations: - Access: O(n) - Search: O(n) - Insertion at beginning/end: O(1) - Deletion at beginning/end: O(1)\n\n\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        last = self.head\n        while last.next:\n            last = last.next\n        last.next = new_node\n        new_node.prev = last\n\n    def __str__(self):\n        if not self.head:\n            return \"empty\"\n        current = self.head\n        result = [\"null\"]\n        while current:\n            result.append(f\"[{current.data}|•|•]\")\n            current = current.next\n        result.append(\"null\")\n        return \" &lt;-&gt; \".join(result)\n\n\ndll = DoublyLinkedList()\ndll.append(3)\ndll.append(7)\ndll.append(1)\ndll.append(9)\ndll.append(4)\nprint(\"Doubly Linked List:\", dll)\n\nDoubly Linked List: null &lt;-&gt; [3|•|•] &lt;-&gt; [7|•|•] &lt;-&gt; [1|•|•] &lt;-&gt; [9|•|•] &lt;-&gt; [4|•|•] &lt;-&gt; null\n\n\n\n\n\n\nIn a circular linked list, the last node points back to the first node, forming a circle.\nExample (Singly Circular):\n    ┌────────────────────────────────┐\n    │                                ▼\n[3|•] -&gt; [7|•] -&gt; [1|•] -&gt; [9|•] -&gt; [4|•]\nOperations: - Similar to singly/doubly linked lists - No null end: facilitates continuous traversal\n\n\n\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass CircularLinkedList:\n    def __init__(self):\n        self.head = None\n\n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            new_node.next = self.head\n            return\n        last = self.head\n        while last.next != self.head:\n            last = last.next\n        last.next = new_node\n        new_node.next = self.head\n\n    def __str__(self):\n        if not self.head:\n            return \"empty\"\n        current = self.head\n        result = []\n        while True:\n            result.append(f\"[{current.data}|•]\")\n            current = current.next\n            if current == self.head:\n                break\n        return \" -&gt; \".join(result) + \" (circular)\"\n\ncll = CircularLinkedList()\ncll.append(3)\ncll.append(7)\ncll.append(1)\ncll.append(9)\ncll.append(4)\nprint(\"Circular Linked List:\", cll)\n\nCircular Linked List: [3|•] -&gt; [7|•] -&gt; [1|•] -&gt; [9|•] -&gt; [4|•] (circular)\n\n\n\n\n\n\n\nDynamic size\nEase of insertion/deletion\nEfficient memory utilization\n\n\n\n\n\nRandom access is not allowed - must be traversed\nExtra memory space for pointers at each node\nNot cache friendly - less cache locality for CPU than a contiguous array - more likely to be randomly scattered around and therefore get cache misses\n\n\n\n\n\nImplementation of stacks and queues\n\nImplementing mutable arrays or collections"
  },
  {
    "objectID": "posts/2024-08-27-linked-lists.html#references-for-linked-lists",
    "href": "posts/2024-08-27-linked-lists.html#references-for-linked-lists",
    "title": "Introduction to Linked Lists",
    "section": "References for Linked Lists",
    "text": "References for Linked Lists\n[^1] HackerRank - Linked Lists Data Structure\n[^2] Stanford CS Education Library - Linked List Basics\n[^3] VisuAlgo - Linked List Visualization\n[^4] leetcode"
  },
  {
    "objectID": "posts/2024-08-24-DSA_1.html",
    "href": "posts/2024-08-24-DSA_1.html",
    "title": "Introduction to Basic Data Structures",
    "section": "",
    "text": "Data structures provide an organised format for data storage, management and access. Most of the following data structures are used in four basic ways:\n\nAccess - provided a location, return the item at that location, or alternatively, return all the items\nSearch - look for a specific item or value, and it’s location\nInsert - add an item into the collection i.e. at the start, end or in between\nDelete - remove an item from the collection\n\nTransformations like sorting and filtering can also be performed. The following are some common and basic data structures:\n\n\n\n\n\nArrays are collections of items, typically stored in contiguous memory:\n| Index | 0 | 1 | 2 | 3 | 4 | 5 |\n|-------|---|---|---|---|---|---|\n| Value | 1 | 2 | 3 | 4 | 5 | 6 |\nEfficiencies:\n\nAccess: O(1)\nSearch: O(n)\nInsertion: O(n)\nDeletion: O(n)\n\n\n\n\nElements are stored in no particular order.\n| Index | 0 | 1 | 2 | 3 | 4 | 5 |\n|-------|---|---|---|---|---|---|\n| Value | 7 | 2 | 9 | 4 | 5 | 1 |\n\nInsertion: O(1) (add to the end)\n\nDeletion: O(n) (need to shift elements)\n\nSearch: O(n) (linear search)\n\n\n\n\nElements are stored in a specific order, typically ascending or descending.\n| Index | 0 | 1 | 2 | 3 | 4 | 5 |\n|-------|---|---|---|---|---|---|\n| Value | 1 | 2 | 4 | 5 | 7 | 9 |\n\nInsertion: O(n) (find position and shift elements)\n\nDeletion: O(n) (shift elements after deletion)\n\nSearch: O(\\log n) (binary search)\n\n\n\n\nThe last element is conceptually followed by the first element, forming a circle.\n    ┌───┐\n┌───┤ 5 ├───┐\n│ 4 │   │ 1 │\n├───┤   ├───┤\n│ 3 │   │ 2 │\n└───┴───┴───┘\n\nUseful for queue implementations\n\nEfficient use of fixed-size array\n\nOperations wrap around the end of the array\n\n\n\n\nAn array where each element is an array, possibly of different lengths.\n| Index | Array                |\n|-------|----------------------|\n|   0   | [1, 2, 3]            |\n|   1   | [4, 5]               |\n|   2   | [6, 7, 8, 9]         |\n|   3   | [10]                 |\n\nFlexible structure for 2D data with varying row lengths\nEfficient for sparse matrices\nAccess: O(1) for both dimensions\n\n\n\n\nAn array where most elements have the same value (usually zero).\nLogical view:\n| 0 | 0 | 0 | 3 | 0 | 0 | 1 | 0 | 0 | 2 | 0 |\nActual storage (index-value pairs):\n| 3:3 | 6:1 | 9:2 |\n\nSpace-efficient for sparse data\n\nSlower access time compared to standard arrays\n\n\n\n\n\n\n\nArray based sets are collections of items, stored in contiguous memory, that do not allow duplicate item to be inserted, and may or may not be sorted:\nUnsorted:\n| Index | 0 | 1 | 2 | 3 | 4 |\n|-------|---|---|---|---|---|\n| Value | 5 | 2 | 8 | 1 | 3 |\nSorted:\n| Index | 0 | 1 | 2 | 3 | 4 |\n|-------|---|---|---|---|---|\n| Value | 1 | 2 | 3 | 5 | 8 |\nEvery insert requires a search first to determine the value to be inserted does not already exist.\nAccess: O(1)\nInsertion:\n- Unsorted: O(1) (append to end)\n- Sorted: O(n) (find correct position and shift elements, to maintain order)\nDeletion: O(n) (need to shift elements to fill the gap)\nSearch:\n- Unsorted: O(n)\n- Sorted: O(\\log n) (using binary search)\n\n\n\nHash table-based sets use a hash function (Section 1.11) to map elements to indices in an array.\nHash function: h(x) = x \\mod 7\ni.e. every input is divided by 7 and the remainder is the output of the hash function (output between 0 and 6)\n\n\n\nIndex\nBucket\n\n\n\n\n0\n7\n\n\n1\n1, 8\n\n\n2\n2\n\n\n3\n3\n\n\n4\n\n\n\n5\n5\n\n\n6\n\n\n\n\n\nCollision - in this example, there is a collision at index 1, with values 1 and 8 returning the same output and therefore being assigned to the same bucket.\nEmpty bucket - important to monitor (or be aware) of the distribution of data which may indicate the hashing function may need to be altered if there are many empty buckets.\n\nAccess: N/A (sets don’t typically support direct access)\nInsertion: \\theta(1) O(n)\nDeletion: \\theta(1) O(n)\nSearch: \\theta(1) O(n)\n\n\n\nTree-based sets store elements in a self-balancing binary search tree (BST). A binary search tree is a data structure composed of nodes. Each node has a key, and each key in the left subtree of a node is less than the node’s key, while each key in the right subtree is greater. Standard operations (search, insert, delete) on a BST generally have action time complexity proportional to the height of the tree.\nThe height of a tree is the length of the longest path from the root node to a leaf node. In a balanced tree, the height is O(\\log ⁡n). If the tree becomes unbalanced (e.g., all nodes added to one side), the height can become O(n).\nA self-balancing BST is a BST that automatically maintains its height after insertions or deletions, which keeps the height as small as possible, ensuring search/insertion/deletion can be performed in O(\\log n) time complexity, where n is the number of nodes in the tree. After every insertion or deletion, the tree checks if it has become unbalanced. If it has, the tree undergoes a series of rotations or restructuring operations to restore balance. The two most common implementations are Red-Black Trees and AVL Trees.\n    4\n   / \\\n  2   6\n / \\ / \\\n1  3 5  7\nGeneral characteristics: - Access: N/A (sets don’t typically support direct access) - Insertion: O(\\log n) - Deletion: O(\\log n) - Search: O(\\log n)\n\n\nRed-Black trees are BSTs with one extra bit of storage per node: its color, which can be either red or black. By constraining the way nodes can be colored, Red-Black trees ensure that no path from the root to a leaf is more than twice as long as any other path.\nProperties: 1. Every node is either red or black. 2. The root is black. 3. Every leaf (NIL) is black. 4. If a node is red, then both its children are black i.e. no two reds in a row 5. For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.\nVisualization:\n    4B\n   /  \\\n  2R   6R\n / \\   / \\\n1B 3B 5B 7B\n(B = Black, R = Red)\nRed-Black trees provide faster insertion and removal operations than AVL trees as they require fewer rotations on average. However, AVL trees provide faster lookups as they are more strictly balanced.\n\n\n\nAVL trees (named after Adelson-Velsky and Landis) are self-balancing binary search trees. In an AVL tree, the heights of the two child subtrees of any node differ by at most one. If, after an insertion or deletion, the tree becomes unbalanced (i.e., the height difference becomes greater than one), rotations are performed to restore balance.\nProperties: 1. The heights of the left and right subtrees of every node differ by at most one. 2. Every subtree is an AVL tree.\nBalance Factor = Height(Left Subtree) - Height(Right Subtree)\nFor any node in an AVL tree, the balance factor must be -1, 0, or 1.\nVisualization:\n    4 (0)\n   /   \\\n2 (-1)  6 (0)\n / \\    / \\\n1   3  5   7\n(Numbers in parentheses represent balance factors)\nAVL trees maintain a stricter balance than Red-Black trees, leading to faster lookups but slower insertion and deletion due to more frequent rotations.\n\n\n\n\nB-Trees are generalisations of self-balancing trees that can have more than two children. B-Trees can be used in databases and file systems because they are work well with systems that read and write large blocks of data.\n\n\n\nA splay tree is a self-balancing BST that performs splaying, a process that moves a given node to the root of the tree by performing a series of tree rotations. Splay trees keep recently accessed elements near the top, making them efficient for specific workload styles.\n\n\n\nBalance:\n\nAVL trees are more rigidly balanced\nRed-Black trees may have longer paths (up to 2 times the shortest path)\n\nOperations:\n\nLookups tend to be faster in AVL trees\nInsertions and deletions tend to be faster in Red-Black trees\n\nUsage:\n\nAVL trees are preferred for lookup-intensive applications\nRed-Black trees are preferred for insertion/deletion-intensive applications\n\n\nBoth tree types guarantee O(\\log n) time complexity for basic operations, making them efficient choices for set and map implementations.\n\n\n\n\n\nBit vector sets use a bit array to represent the presence or absence of elements.\n\n\nUniverse: {0, 1, 2, 3, 4, 5, 6, 7}\nSet: {1, 2, 4, 7}\n\nBit Vector: \n| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |\n| 0 | 1 | 1 | 0 | 1 | 0 | 0 | 1 |\n\nAccess: O(1)\n\nInsertion: O(1)\n\nDeletion: O(1)\n\nSearch: O(1)\n\n\n\n\n\nArray-based sets are simple but inefficient for large, dynamic sets.\nHash table-based sets offer great average-case performance.\nTree-based sets provide balanced performance and maintain order.\nBit vector sets are highly efficient but limited in applicability.\n\nChoosing between them depends on the expected set size, frequency of operations, memory constraints, and need for maintaining order.\n\n\n\n\nA linked list consists of nodes where each node contains a data field and a reference to the next node in the sequence.\n[3] -&gt; [7] -&gt; [1] -&gt; [9] -&gt; [4] -&gt; null\nAccess: O(n) Search: O(n) Insertion: O(1) Deletion: O(1)\n\n\n\nA stack follows the Last In First Out (LIFO) principle.\n| 4 | &lt;- Top\n| 9 |\n| 1 |\n| 7 |\n| 3 |\nPush: O(1) Pop: O(1) Peek: O(1)\n\n\n\nA queue follows the First In First Out (FIFO) principle.\nFront -&gt; [3] -&gt; [7] -&gt; [1] -&gt; [9] -&gt; [4] &lt;- Rear\nEnqueue: O(1) Dequeue: O(1) Front: O(1)\n\n\n\nA tree is a hierarchical structure with a root node and child nodes.\n    1\n   / \\\n  2   3\n / \\   \\\n4   5   6\nAccess: O(\\log n) (for balanced trees) Search: O(\\log n) (for balanced trees) Insertion: O(\\log n) (for balanced trees) Deletion: O(\\log n) (for balanced trees)\n\n\n\nA graph consists of vertices connected by edges.\n    A --- B\n    |   / |\n    |  /  |\n    | /   |\n    C --- D\nTraversal: O(V + E) where V is the number of vertices and E is the number of edges\n\n\n\nA hash table stores key-value pairs and uses a hash function to compute an index into an array of buckets.\n\n\n\nKey\nHash\nIndex\nValue\n\n\n\n\n“apple”\nhash(“apple”)\n2\n5\n\n\n“banana”\nhash(“banana”)\n4\n8\n\n\n“cherry”\nhash(“cherry”)\n1\n3\n\n\n\nAccess: \\theta(1), O(n)\nSearch: \\theta(1), O(n)\nInsertion: \\theta(1), O(n)\nDeletion: \\theta(1), O(n)\n\n\n\n\n\nh(x) = x \\mod n\nTake the modulus of some input value by some number, n, where n is usually a prime number (Link).\n\n\n\nThe multiplication method involves multiplying the input value x by a constant A (where 0 &lt; A &lt; 1), taking the fractional part of the result, and then multiplying by the size of the hash table m:\nh(x) = \\left\\lfloor m \\times (x \\times A \\mod 1) \\right\\rfloor\nLet’s choose m = 10 and A = \\frac{\\sqrt{5} - 1}{2} \\approx 0.6180339887\nFor x = 123:\n\nMultiply: 123 \\times 0.6180339887 = 76.01818\n\nTake fractional part: 0.01818\n\nMultiply by m: 10 \\times 0.01818 = 0.1818\n\nFloor the result: \\lfloor 0.1818 \\rfloor = 0\n\nSo, h(123) = 0\n\n\n\nThe mid-square method involves squaring the key and taking the middle digits:\n\nSquare the key\n\nExtract a fixed number of digits from the middle\n\nUse these digits as the hash value\n\nFor key x = 3791 and a 4-digit hash:\n\nSquare: 3791^2 = 14371681\n\nExtract middle 4 digits: 3716\n\nSo, h(3791) = 3716\n\n\n\nThe folding method involves dividing the key into equal-sized parts (except possibly the last part) and combining these parts using addition or XOR:\n\nDivide the key into equal-sized parts\nSum or XOR these parts\nTake the result modulo the table size\n\nFor key x = 12345678 and 2-digit parts:\n\nDivide: 12|34|56|78\nSum: 12 + 34 + 56 + 78 = 180\nIf table size is 100: 180 \\mod 100 = 80\n\nSo, h(12345678) = 80"
  },
  {
    "objectID": "posts/2024-08-24-DSA_1.html#introduction",
    "href": "posts/2024-08-24-DSA_1.html#introduction",
    "title": "Introduction to Basic Data Structures",
    "section": "",
    "text": "Data structures provide an organised format for data storage, management and access. Most of the following data structures are used in four basic ways:\n\nAccess - provided a location, return the item at that location, or alternatively, return all the items\nSearch - look for a specific item or value, and it’s location\nInsert - add an item into the collection i.e. at the start, end or in between\nDelete - remove an item from the collection\n\nTransformations like sorting and filtering can also be performed. The following are some common and basic data structures:"
  },
  {
    "objectID": "posts/2024-08-24-DSA_1.html#arrays",
    "href": "posts/2024-08-24-DSA_1.html#arrays",
    "title": "Introduction to Basic Data Structures",
    "section": "",
    "text": "Arrays are collections of items, typically stored in contiguous memory:\n| Index | 0 | 1 | 2 | 3 | 4 | 5 |\n|-------|---|---|---|---|---|---|\n| Value | 1 | 2 | 3 | 4 | 5 | 6 |\nEfficiencies:\n\nAccess: O(1)\nSearch: O(n)\nInsertion: O(n)\nDeletion: O(n)\n\n\n\n\nElements are stored in no particular order.\n| Index | 0 | 1 | 2 | 3 | 4 | 5 |\n|-------|---|---|---|---|---|---|\n| Value | 7 | 2 | 9 | 4 | 5 | 1 |\n\nInsertion: O(1) (add to the end)\n\nDeletion: O(n) (need to shift elements)\n\nSearch: O(n) (linear search)\n\n\n\n\nElements are stored in a specific order, typically ascending or descending.\n| Index | 0 | 1 | 2 | 3 | 4 | 5 |\n|-------|---|---|---|---|---|---|\n| Value | 1 | 2 | 4 | 5 | 7 | 9 |\n\nInsertion: O(n) (find position and shift elements)\n\nDeletion: O(n) (shift elements after deletion)\n\nSearch: O(\\log n) (binary search)\n\n\n\n\nThe last element is conceptually followed by the first element, forming a circle.\n    ┌───┐\n┌───┤ 5 ├───┐\n│ 4 │   │ 1 │\n├───┤   ├───┤\n│ 3 │   │ 2 │\n└───┴───┴───┘\n\nUseful for queue implementations\n\nEfficient use of fixed-size array\n\nOperations wrap around the end of the array\n\n\n\n\nAn array where each element is an array, possibly of different lengths.\n| Index | Array                |\n|-------|----------------------|\n|   0   | [1, 2, 3]            |\n|   1   | [4, 5]               |\n|   2   | [6, 7, 8, 9]         |\n|   3   | [10]                 |\n\nFlexible structure for 2D data with varying row lengths\nEfficient for sparse matrices\nAccess: O(1) for both dimensions\n\n\n\n\nAn array where most elements have the same value (usually zero).\nLogical view:\n| 0 | 0 | 0 | 3 | 0 | 0 | 1 | 0 | 0 | 2 | 0 |\nActual storage (index-value pairs):\n| 3:3 | 6:1 | 9:2 |\n\nSpace-efficient for sparse data\n\nSlower access time compared to standard arrays"
  },
  {
    "objectID": "posts/2024-08-24-DSA_1.html#sets",
    "href": "posts/2024-08-24-DSA_1.html#sets",
    "title": "Introduction to Basic Data Structures",
    "section": "",
    "text": "Array based sets are collections of items, stored in contiguous memory, that do not allow duplicate item to be inserted, and may or may not be sorted:\nUnsorted:\n| Index | 0 | 1 | 2 | 3 | 4 |\n|-------|---|---|---|---|---|\n| Value | 5 | 2 | 8 | 1 | 3 |\nSorted:\n| Index | 0 | 1 | 2 | 3 | 4 |\n|-------|---|---|---|---|---|\n| Value | 1 | 2 | 3 | 5 | 8 |\nEvery insert requires a search first to determine the value to be inserted does not already exist.\nAccess: O(1)\nInsertion:\n- Unsorted: O(1) (append to end)\n- Sorted: O(n) (find correct position and shift elements, to maintain order)\nDeletion: O(n) (need to shift elements to fill the gap)\nSearch:\n- Unsorted: O(n)\n- Sorted: O(\\log n) (using binary search)\n\n\n\nHash table-based sets use a hash function (Section 1.11) to map elements to indices in an array.\nHash function: h(x) = x \\mod 7\ni.e. every input is divided by 7 and the remainder is the output of the hash function (output between 0 and 6)\n\n\n\nIndex\nBucket\n\n\n\n\n0\n7\n\n\n1\n1, 8\n\n\n2\n2\n\n\n3\n3\n\n\n4\n\n\n\n5\n5\n\n\n6\n\n\n\n\n\nCollision - in this example, there is a collision at index 1, with values 1 and 8 returning the same output and therefore being assigned to the same bucket.\nEmpty bucket - important to monitor (or be aware) of the distribution of data which may indicate the hashing function may need to be altered if there are many empty buckets.\n\nAccess: N/A (sets don’t typically support direct access)\nInsertion: \\theta(1) O(n)\nDeletion: \\theta(1) O(n)\nSearch: \\theta(1) O(n)\n\n\n\nTree-based sets store elements in a self-balancing binary search tree (BST). A binary search tree is a data structure composed of nodes. Each node has a key, and each key in the left subtree of a node is less than the node’s key, while each key in the right subtree is greater. Standard operations (search, insert, delete) on a BST generally have action time complexity proportional to the height of the tree.\nThe height of a tree is the length of the longest path from the root node to a leaf node. In a balanced tree, the height is O(\\log ⁡n). If the tree becomes unbalanced (e.g., all nodes added to one side), the height can become O(n).\nA self-balancing BST is a BST that automatically maintains its height after insertions or deletions, which keeps the height as small as possible, ensuring search/insertion/deletion can be performed in O(\\log n) time complexity, where n is the number of nodes in the tree. After every insertion or deletion, the tree checks if it has become unbalanced. If it has, the tree undergoes a series of rotations or restructuring operations to restore balance. The two most common implementations are Red-Black Trees and AVL Trees.\n    4\n   / \\\n  2   6\n / \\ / \\\n1  3 5  7\nGeneral characteristics: - Access: N/A (sets don’t typically support direct access) - Insertion: O(\\log n) - Deletion: O(\\log n) - Search: O(\\log n)\n\n\nRed-Black trees are BSTs with one extra bit of storage per node: its color, which can be either red or black. By constraining the way nodes can be colored, Red-Black trees ensure that no path from the root to a leaf is more than twice as long as any other path.\nProperties: 1. Every node is either red or black. 2. The root is black. 3. Every leaf (NIL) is black. 4. If a node is red, then both its children are black i.e. no two reds in a row 5. For each node, all simple paths from the node to descendant leaves contain the same number of black nodes.\nVisualization:\n    4B\n   /  \\\n  2R   6R\n / \\   / \\\n1B 3B 5B 7B\n(B = Black, R = Red)\nRed-Black trees provide faster insertion and removal operations than AVL trees as they require fewer rotations on average. However, AVL trees provide faster lookups as they are more strictly balanced.\n\n\n\nAVL trees (named after Adelson-Velsky and Landis) are self-balancing binary search trees. In an AVL tree, the heights of the two child subtrees of any node differ by at most one. If, after an insertion or deletion, the tree becomes unbalanced (i.e., the height difference becomes greater than one), rotations are performed to restore balance.\nProperties: 1. The heights of the left and right subtrees of every node differ by at most one. 2. Every subtree is an AVL tree.\nBalance Factor = Height(Left Subtree) - Height(Right Subtree)\nFor any node in an AVL tree, the balance factor must be -1, 0, or 1.\nVisualization:\n    4 (0)\n   /   \\\n2 (-1)  6 (0)\n / \\    / \\\n1   3  5   7\n(Numbers in parentheses represent balance factors)\nAVL trees maintain a stricter balance than Red-Black trees, leading to faster lookups but slower insertion and deletion due to more frequent rotations.\n\n\n\n\nB-Trees are generalisations of self-balancing trees that can have more than two children. B-Trees can be used in databases and file systems because they are work well with systems that read and write large blocks of data.\n\n\n\nA splay tree is a self-balancing BST that performs splaying, a process that moves a given node to the root of the tree by performing a series of tree rotations. Splay trees keep recently accessed elements near the top, making them efficient for specific workload styles.\n\n\n\nBalance:\n\nAVL trees are more rigidly balanced\nRed-Black trees may have longer paths (up to 2 times the shortest path)\n\nOperations:\n\nLookups tend to be faster in AVL trees\nInsertions and deletions tend to be faster in Red-Black trees\n\nUsage:\n\nAVL trees are preferred for lookup-intensive applications\nRed-Black trees are preferred for insertion/deletion-intensive applications\n\n\nBoth tree types guarantee O(\\log n) time complexity for basic operations, making them efficient choices for set and map implementations."
  },
  {
    "objectID": "posts/2024-08-24-DSA_1.html#bit-vector-sets",
    "href": "posts/2024-08-24-DSA_1.html#bit-vector-sets",
    "title": "Introduction to Basic Data Structures",
    "section": "",
    "text": "Bit vector sets use a bit array to represent the presence or absence of elements.\n\n\nUniverse: {0, 1, 2, 3, 4, 5, 6, 7}\nSet: {1, 2, 4, 7}\n\nBit Vector: \n| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |\n| 0 | 1 | 1 | 0 | 1 | 0 | 0 | 1 |\n\nAccess: O(1)\n\nInsertion: O(1)\n\nDeletion: O(1)\n\nSearch: O(1)\n\n\n\n\n\nArray-based sets are simple but inefficient for large, dynamic sets.\nHash table-based sets offer great average-case performance.\nTree-based sets provide balanced performance and maintain order.\nBit vector sets are highly efficient but limited in applicability.\n\nChoosing between them depends on the expected set size, frequency of operations, memory constraints, and need for maintaining order."
  },
  {
    "objectID": "posts/2024-08-24-DSA_1.html#linked-list",
    "href": "posts/2024-08-24-DSA_1.html#linked-list",
    "title": "Introduction to Basic Data Structures",
    "section": "",
    "text": "A linked list consists of nodes where each node contains a data field and a reference to the next node in the sequence.\n[3] -&gt; [7] -&gt; [1] -&gt; [9] -&gt; [4] -&gt; null\nAccess: O(n) Search: O(n) Insertion: O(1) Deletion: O(1)"
  },
  {
    "objectID": "posts/2024-08-24-DSA_1.html#stack",
    "href": "posts/2024-08-24-DSA_1.html#stack",
    "title": "Introduction to Basic Data Structures",
    "section": "",
    "text": "A stack follows the Last In First Out (LIFO) principle.\n| 4 | &lt;- Top\n| 9 |\n| 1 |\n| 7 |\n| 3 |\nPush: O(1) Pop: O(1) Peek: O(1)"
  },
  {
    "objectID": "posts/2024-08-24-DSA_1.html#queue",
    "href": "posts/2024-08-24-DSA_1.html#queue",
    "title": "Introduction to Basic Data Structures",
    "section": "",
    "text": "A queue follows the First In First Out (FIFO) principle.\nFront -&gt; [3] -&gt; [7] -&gt; [1] -&gt; [9] -&gt; [4] &lt;- Rear\nEnqueue: O(1) Dequeue: O(1) Front: O(1)"
  },
  {
    "objectID": "posts/2024-08-24-DSA_1.html#tree",
    "href": "posts/2024-08-24-DSA_1.html#tree",
    "title": "Introduction to Basic Data Structures",
    "section": "",
    "text": "A tree is a hierarchical structure with a root node and child nodes.\n    1\n   / \\\n  2   3\n / \\   \\\n4   5   6\nAccess: O(\\log n) (for balanced trees) Search: O(\\log n) (for balanced trees) Insertion: O(\\log n) (for balanced trees) Deletion: O(\\log n) (for balanced trees)"
  },
  {
    "objectID": "posts/2024-08-24-DSA_1.html#graph",
    "href": "posts/2024-08-24-DSA_1.html#graph",
    "title": "Introduction to Basic Data Structures",
    "section": "",
    "text": "A graph consists of vertices connected by edges.\n    A --- B\n    |   / |\n    |  /  |\n    | /   |\n    C --- D\nTraversal: O(V + E) where V is the number of vertices and E is the number of edges"
  },
  {
    "objectID": "posts/2024-08-24-DSA_1.html#hash-table",
    "href": "posts/2024-08-24-DSA_1.html#hash-table",
    "title": "Introduction to Basic Data Structures",
    "section": "",
    "text": "A hash table stores key-value pairs and uses a hash function to compute an index into an array of buckets.\n\n\n\nKey\nHash\nIndex\nValue\n\n\n\n\n“apple”\nhash(“apple”)\n2\n5\n\n\n“banana”\nhash(“banana”)\n4\n8\n\n\n“cherry”\nhash(“cherry”)\n1\n3\n\n\n\nAccess: \\theta(1), O(n)\nSearch: \\theta(1), O(n)\nInsertion: \\theta(1), O(n)\nDeletion: \\theta(1), O(n)"
  },
  {
    "objectID": "posts/2024-08-24-DSA_1.html#sec-hash-functions",
    "href": "posts/2024-08-24-DSA_1.html#sec-hash-functions",
    "title": "Introduction to Basic Data Structures",
    "section": "",
    "text": "h(x) = x \\mod n\nTake the modulus of some input value by some number, n, where n is usually a prime number (Link).\n\n\n\nThe multiplication method involves multiplying the input value x by a constant A (where 0 &lt; A &lt; 1), taking the fractional part of the result, and then multiplying by the size of the hash table m:\nh(x) = \\left\\lfloor m \\times (x \\times A \\mod 1) \\right\\rfloor\nLet’s choose m = 10 and A = \\frac{\\sqrt{5} - 1}{2} \\approx 0.6180339887\nFor x = 123:\n\nMultiply: 123 \\times 0.6180339887 = 76.01818\n\nTake fractional part: 0.01818\n\nMultiply by m: 10 \\times 0.01818 = 0.1818\n\nFloor the result: \\lfloor 0.1818 \\rfloor = 0\n\nSo, h(123) = 0\n\n\n\nThe mid-square method involves squaring the key and taking the middle digits:\n\nSquare the key\n\nExtract a fixed number of digits from the middle\n\nUse these digits as the hash value\n\nFor key x = 3791 and a 4-digit hash:\n\nSquare: 3791^2 = 14371681\n\nExtract middle 4 digits: 3716\n\nSo, h(3791) = 3716\n\n\n\nThe folding method involves dividing the key into equal-sized parts (except possibly the last part) and combining these parts using addition or XOR:\n\nDivide the key into equal-sized parts\nSum or XOR these parts\nTake the result modulo the table size\n\nFor key x = 12345678 and 2-digit parts:\n\nDivide: 12|34|56|78\nSum: 12 + 34 + 56 + 78 = 180\nIf table size is 100: 180 \\mod 100 = 80\n\nSo, h(12345678) = 80"
  },
  {
    "objectID": "posts/2023-04-03-inductive-program-synthesis.html",
    "href": "posts/2023-04-03-inductive-program-synthesis.html",
    "title": "Inductive Program Synthesis",
    "section": "",
    "text": "A simple implementation would be to construct all possible programs from the terminals of a grammar. This can be inefficient as the space of all expressions can grow quickly. Observationally equivalent programs are discarded (i.e. if the same output is generated based on the same input, the primitive can be discarded), which reduces the solution space exponentially.\nfunction synthesise (inputs, outputs):\n  terms := set_of_all_terminals\n  while(true):\n    terms := grow(terms)\n    terms := eliminate_observational_equivalents(terms, inputs);\n    foreach(t in terms):\n      if(is_correct(t, inputs, outputs)):\n        return t;\nOne characteristic is that bottom-up search explores small programs before larger ones, so it can potentially find the smallest program that satisfies the specification. Further heuristics can be applied in the grow or eliminate function level to direct the search, and it copes well with symmetry reduction. However, even with aggressive pruning, it is hard to scale beyond small lists of terms, and whilst it can connect discrete components, it is not effective at determining constants. It also may fail at pruning if the language has context dependant semantics e.g. if the same expression had dufferent values in different contexts e.g. via mutation.\n\n\n\nBy modularising the search, i.e. search for multiple programs that work for different inputs and find a way to combine them that will work for all inputs, the scalability can be improved. The first step is a best-effort synthesis (if it works on all then it is just returned), then it can try to either improve the current program by taking a selection of the currently failing inputs alongside the correctly mapped inputs, or STUN can be called recursively on the inputs where the synthesised program failed. Then the programs can be combined. #### Anti/Unification If there are no top-level branches to allow unification, antiunification can be used. Unification is finding a common structure for two different expressions by replacing variables with expressions. Antiunification is to process of finding the common structure by replacing expressions with variables. For example, if we find 2 expressions a \\times c and b \\times c cover all inputs, antiunification can produce a common expression v \\times c where v stands for a code fragment that can be solved, being a much smaller synthesis problem. When a recursive call to STUN is made, additional constraints can also be passed that the expression must satisfy to avoid situations where, for example, anntiunification cannot be used e.g. b \\times c would be chosen over -b as b \\times c can be antiunified with a \\times c. \\bigoplus represents unification.\n\n\n\nModularisation may also be performed if the program can be split into different levels of abstraction, and the search performed independently at each level. A potential optimisation here is if we can eliminate branches where the output is not a superset of the input set.\n\n\n\nTop down search can utilise types to assist in pruning invalid programs efficiently. A basic algorithm will start from the grammar rules and test with the inputs, pruning out programs that are fully expanded which don’t return the correct output or which return incompatible types. Some languages will have infinite types, e.g. for supporting nested lists and functions. Typing rules have the following form:  \\frac{premises}{context ⊢ expr : \\tau }  ⊢ = proves or satisfies or is derived or assuming expr will have type \\tau in a given context as long as all the premises are satisfied. Alternatively:  \\frac{conditions}{Examples, ⊢ expression : \\tau } \nAn example typing rule might be:  \\frac{\\bold{\\textit C},x : \\tau_1 ⊢ expr : \\tau_2}{\\bold{\\textit C} ⊢ \\bold{\\lambda}x.expr : \\tau_1 \\to \\tau_2 }  states the following: \\bold{\\lambda}x.expr will have type \\tau_1 \\to \\tau_2 if it can be shown that expr has type \\tau_2 in a context that is like the context \\bold{\\textit C} but that also has x as having type \\tau_1.\nThe search space can also be further restricted in further iterations/generations for functions like map; if the expected output is an array of integer arrays, the first expression must correspond to a function with a type of integer array, allowing filtering of programs that won’t have the desired type before evaluating any concrete input values.\n\n\nType rules are a form of deductive rule; information about inputs/outputs are propogated to potential sub-expressions. Additional rules for different constructs in the language can prune the solution space. Given a candidate expression with an unknown subexpression \\bold{\\textit f} and a set of input-outputs, the input-outputs can be propogated to the subexpression or establish that this line is not viable. Rules can inform the search if a candidate is not going to work e.g. map will always return a list of the same length so if the input length is different, map alone will not be viable. They can also provide information on how to propogate input-outputs to new expressions. It may not work when expressions involve functions e.g. if the same input value is mapped to multiple output values.\n\n\n\n\n\n\nA probabilistic process where there is a finite set of states $ $, and the probability of transitioning from a given state x to a different state y at each step of the process, is given by matrix $ (x,y): $ where $ (x,y) $ and $ _y (x,y) = 1 $. Becuase the values of \\bold{\\textit K} are probabilities, \\forall x,y. 0 \\le \\bold{\\textit K}(x,y) &lt; 1.0 and at every state there will be a transition (potentially to the same state) so \\forall x.\\sum_{y\\in{\\chi}} \\bold{\\textit K}(x,y) = 1.0.\nA markov chain is a sequence of states \\textit X_0, \\textit X_1, \\textit X_2,... in a markov process. The probability of the whole chain is the product of the probability of each transition:  (\\textit X_1 = y|\\textit X_0 = x) = \\bold{\\textit K}   \\bold{\\textit P}(\\textit X_1 = y, \\textit X_2 = z|\\textit X_0 = x) = \\bold{\\textit K}   \\bold{\\textit P}(\\textit X_2 = z|\\textit X_0 = x) = \\sum_y \\bold{\\textit K(x,y)} \\times \\bold{\\textit K(y,z)}  To obtain the probability that X_2 = z given a starting point of X_0 = x, then we need to consider all the possible states of X_1 to get from x to z. This is $ _y $. \\bold{\\textit K} is a matrix which gives the probability of transitioning from x to y in one step. \\bold{\\textit K}^2 is the probability of transitioning in 2 steps, and \\bold{\\textit K}^n (x,y) is the probability of transitioning from x to y in exactly n steps."
  },
  {
    "objectID": "posts/2023-04-03-inductive-program-synthesis.html#explicit",
    "href": "posts/2023-04-03-inductive-program-synthesis.html#explicit",
    "title": "Inductive Program Synthesis",
    "section": "",
    "text": "A simple implementation would be to construct all possible programs from the terminals of a grammar. This can be inefficient as the space of all expressions can grow quickly. Observationally equivalent programs are discarded (i.e. if the same output is generated based on the same input, the primitive can be discarded), which reduces the solution space exponentially.\nfunction synthesise (inputs, outputs):\n  terms := set_of_all_terminals\n  while(true):\n    terms := grow(terms)\n    terms := eliminate_observational_equivalents(terms, inputs);\n    foreach(t in terms):\n      if(is_correct(t, inputs, outputs)):\n        return t;\nOne characteristic is that bottom-up search explores small programs before larger ones, so it can potentially find the smallest program that satisfies the specification. Further heuristics can be applied in the grow or eliminate function level to direct the search, and it copes well with symmetry reduction. However, even with aggressive pruning, it is hard to scale beyond small lists of terms, and whilst it can connect discrete components, it is not effective at determining constants. It also may fail at pruning if the language has context dependant semantics e.g. if the same expression had dufferent values in different contexts e.g. via mutation.\n\n\n\nBy modularising the search, i.e. search for multiple programs that work for different inputs and find a way to combine them that will work for all inputs, the scalability can be improved. The first step is a best-effort synthesis (if it works on all then it is just returned), then it can try to either improve the current program by taking a selection of the currently failing inputs alongside the correctly mapped inputs, or STUN can be called recursively on the inputs where the synthesised program failed. Then the programs can be combined. #### Anti/Unification If there are no top-level branches to allow unification, antiunification can be used. Unification is finding a common structure for two different expressions by replacing variables with expressions. Antiunification is to process of finding the common structure by replacing expressions with variables. For example, if we find 2 expressions a \\times c and b \\times c cover all inputs, antiunification can produce a common expression v \\times c where v stands for a code fragment that can be solved, being a much smaller synthesis problem. When a recursive call to STUN is made, additional constraints can also be passed that the expression must satisfy to avoid situations where, for example, anntiunification cannot be used e.g. b \\times c would be chosen over -b as b \\times c can be antiunified with a \\times c. \\bigoplus represents unification.\n\n\n\nModularisation may also be performed if the program can be split into different levels of abstraction, and the search performed independently at each level. A potential optimisation here is if we can eliminate branches where the output is not a superset of the input set.\n\n\n\nTop down search can utilise types to assist in pruning invalid programs efficiently. A basic algorithm will start from the grammar rules and test with the inputs, pruning out programs that are fully expanded which don’t return the correct output or which return incompatible types. Some languages will have infinite types, e.g. for supporting nested lists and functions. Typing rules have the following form:  \\frac{premises}{context ⊢ expr : \\tau }  ⊢ = proves or satisfies or is derived or assuming expr will have type \\tau in a given context as long as all the premises are satisfied. Alternatively:  \\frac{conditions}{Examples, ⊢ expression : \\tau } \nAn example typing rule might be:  \\frac{\\bold{\\textit C},x : \\tau_1 ⊢ expr : \\tau_2}{\\bold{\\textit C} ⊢ \\bold{\\lambda}x.expr : \\tau_1 \\to \\tau_2 }  states the following: \\bold{\\lambda}x.expr will have type \\tau_1 \\to \\tau_2 if it can be shown that expr has type \\tau_2 in a context that is like the context \\bold{\\textit C} but that also has x as having type \\tau_1.\nThe search space can also be further restricted in further iterations/generations for functions like map; if the expected output is an array of integer arrays, the first expression must correspond to a function with a type of integer array, allowing filtering of programs that won’t have the desired type before evaluating any concrete input values.\n\n\nType rules are a form of deductive rule; information about inputs/outputs are propogated to potential sub-expressions. Additional rules for different constructs in the language can prune the solution space. Given a candidate expression with an unknown subexpression \\bold{\\textit f} and a set of input-outputs, the input-outputs can be propogated to the subexpression or establish that this line is not viable. Rules can inform the search if a candidate is not going to work e.g. map will always return a list of the same length so if the input length is different, map alone will not be viable. They can also provide information on how to propogate input-outputs to new expressions. It may not work when expressions involve functions e.g. if the same input value is mapped to multiple output values.\n\n\n\n\n\n\nA probabilistic process where there is a finite set of states $ $, and the probability of transitioning from a given state x to a different state y at each step of the process, is given by matrix $ (x,y): $ where $ (x,y) $ and $ _y (x,y) = 1 $. Becuase the values of \\bold{\\textit K} are probabilities, \\forall x,y. 0 \\le \\bold{\\textit K}(x,y) &lt; 1.0 and at every state there will be a transition (potentially to the same state) so \\forall x.\\sum_{y\\in{\\chi}} \\bold{\\textit K}(x,y) = 1.0.\nA markov chain is a sequence of states \\textit X_0, \\textit X_1, \\textit X_2,... in a markov process. The probability of the whole chain is the product of the probability of each transition:  (\\textit X_1 = y|\\textit X_0 = x) = \\bold{\\textit K}   \\bold{\\textit P}(\\textit X_1 = y, \\textit X_2 = z|\\textit X_0 = x) = \\bold{\\textit K}   \\bold{\\textit P}(\\textit X_2 = z|\\textit X_0 = x) = \\sum_y \\bold{\\textit K(x,y)} \\times \\bold{\\textit K(y,z)}  To obtain the probability that X_2 = z given a starting point of X_0 = x, then we need to consider all the possible states of X_1 to get from x to z. This is $ _y $. \\bold{\\textit K} is a matrix which gives the probability of transitioning from x to y in one step. \\bold{\\textit K}^2 is the probability of transitioning in 2 steps, and \\bold{\\textit K}^n (x,y) is the probability of transitioning from x to y in exactly n steps."
  },
  {
    "objectID": "posts/2022-04-30-tensors.html",
    "href": "posts/2022-04-30-tensors.html",
    "title": "Tensors and Tensor Operations",
    "section": "",
    "text": "Transpose of a scalar is the scalar itself i.e. x{^T} = x\n\n\n\nTransposing a vector transofrms columns to rows, and rows to columns i.e.\n\n\\begin{bmatrix} x{_{1,1}} & x{_{1,2}} \\\\ x{_{2,1}} & x{_{2,2}} \\\\ x{_{3,1}} & x{_{3,2}}\n\\end{bmatrix}{^T} =\n\\begin{bmatrix}\nx{_{1,1}} & x{_{2,1}} & x{_{3,1}} \\\\\nx{_{1,2}} & x{_{2,2}} & x{_{3,2}}\n\\end{bmatrix}\n\nScalar and vector transpoition are special cases of matrix transposition, where the axes are “flipped” across the main diagonal.\n(\\boldsymbol X^T)_{i,j} = (\\boldsymbol X)_{j,i} \n\n\n\n\n\n\nCalculate the sum across all elements of the vector or matrix.\nVector ${i=1}^n x_i $\nMatrix ${i=1}^m {j=1}^n X{j,i} $\n\n\n\n\nDifferent to the Hadamard product as there is summation in the dot product (or scalar product) to produce a single scalar value.\nCan calculate the dot product if two vectors tensors x and y have the same length n and can be denoted as: \\boldsymbol X\\cdot \\boldsymbol Y ,\\boldsymbol X^T \\boldsymbol Y or \\lang \\boldsymbol X,\\boldsymbol Y \\rang. The product is calculated in an elemnent-wise pattern, then summed across the products to produce a scalar value:\n\\boldsymbol X \\cdot \\boldsymbol Y = \\sum_{i=1}^n x_iy_i"
  },
  {
    "objectID": "posts/2022-04-30-tensors.html#tensor-transposition",
    "href": "posts/2022-04-30-tensors.html#tensor-transposition",
    "title": "Tensors and Tensor Operations",
    "section": "",
    "text": "Transpose of a scalar is the scalar itself i.e. x{^T} = x\n\n\n\nTransposing a vector transofrms columns to rows, and rows to columns i.e.\n\n\\begin{bmatrix} x{_{1,1}} & x{_{1,2}} \\\\ x{_{2,1}} & x{_{2,2}} \\\\ x{_{3,1}} & x{_{3,2}}\n\\end{bmatrix}{^T} =\n\\begin{bmatrix}\nx{_{1,1}} & x{_{2,1}} & x{_{3,1}} \\\\\nx{_{1,2}} & x{_{2,2}} & x{_{3,2}}\n\\end{bmatrix}\n\nScalar and vector transpoition are special cases of matrix transposition, where the axes are “flipped” across the main diagonal.\n(\\boldsymbol X^T)_{i,j} = (\\boldsymbol X)_{j,i}"
  },
  {
    "objectID": "posts/2022-04-30-tensors.html#tensor-reduction",
    "href": "posts/2022-04-30-tensors.html#tensor-reduction",
    "title": "Tensors and Tensor Operations",
    "section": "",
    "text": "Calculate the sum across all elements of the vector or matrix.\nVector ${i=1}^n x_i $\nMatrix ${i=1}^m {j=1}^n X{j,i} $"
  },
  {
    "objectID": "posts/2022-04-30-tensors.html#dot-product",
    "href": "posts/2022-04-30-tensors.html#dot-product",
    "title": "Tensors and Tensor Operations",
    "section": "",
    "text": "Different to the Hadamard product as there is summation in the dot product (or scalar product) to produce a single scalar value.\nCan calculate the dot product if two vectors tensors x and y have the same length n and can be denoted as: \\boldsymbol X\\cdot \\boldsymbol Y ,\\boldsymbol X^T \\boldsymbol Y or \\lang \\boldsymbol X,\\boldsymbol Y \\rang. The product is calculated in an elemnent-wise pattern, then summed across the products to produce a scalar value:\n\\boldsymbol X \\cdot \\boldsymbol Y = \\sum_{i=1}^n x_iy_i"
  },
  {
    "objectID": "posts/2022-04-30-eigenvectors.html",
    "href": "posts/2022-04-30-eigenvectors.html",
    "title": "Eigenvectors and Eigenvalues",
    "section": "",
    "text": "Coming soon!\n\n\nCh 1-7 Strang 1 Ch 2 Goodfellow 2"
  },
  {
    "objectID": "posts/2022-04-30-eigenvectors.html#footnotes",
    "href": "posts/2022-04-30-eigenvectors.html#footnotes",
    "title": "Eigenvectors and Eigenvalues",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nGilbert Strang. Introduction to linear algebra. Cambridge Press, Wellesley, MA, 2016.↩︎\nIan Goodfellow et Al. Deep learning. MIT press, 2016.↩︎"
  },
  {
    "objectID": "posts/2022-04-19-ml-forms.html",
    "href": "posts/2022-04-19-ml-forms.html",
    "title": "Forms of ML",
    "section": "",
    "text": "Here are a few ways commonly used to classify ML systems:\n\nsupervision based\nincremental learning based\ngeneralisability\n\n\n\nIn this classification, there are four main classes based on the amount or type of supervision\n\n\n\nData\n\nLabelled examples \\large{({\\bold x_i},y_i)_{i=1}^N}\n\\large x_i is a feature vector(\\large n-dimensional vector of numerical features \\large x^d)\n\nrepresent objects numerically e.g. for an image, \\large x^{(1)} could be the hue, and \\large x^{(2)} could be the intensity\nuseful for comparing objects e.g. euclidean distance\ngranularity depends on the purpose\n\n\\large y_i can take the form of a member of a set, real number, matrix, vector etc.\n\nTasks\n\nClassification e.g. spam filter\nPredict numeric values based on predictors (features) e.g. house price given room numbers and areas\n\nGoal\n\nTrain a model on a dataset to predict labels based on input feature vectors\n\nMethods\n\nLinear regression\nLogistic regression\nkNN\nSVM\nDT (& random forests)\nNeural networks\n\n\n\n\n\n\nData\n\nUnlabelled examples \\large{({\\bold x_i})_{i=1}^N}\n\\large x_i is a feature vector\n\nTasks\n\nClustering - group data points with shared attributes to extrapolate a relationship e.g. molecular structure similarity\nAnomaly/Outlier detection - find outliers e.g. fraud-detection\nRule learning\n\nGoal\n\nClustering - transform feature vector \\large \\bold x into a useful value e.g. an id\nDimensionality reduction - output feature vector should have fewer features than \\large \\bold x\nAnomaly/Outlier detection - output value quantifies the difference of \\large \\bold x from the data\n\nMethods\n\nClustering\n\nExclusive\n\nK-means\nHierarchical\n\nSoft - more probabilistic\n\nGMM\nExpectation Maximisation\n\n\nAssociation\n\nApriori\nEclat\n\nDimensionality reduction\n\nPCA\nSVD\nLLE\nt-SNE\n\n\nChallenges\n\nComputation and time complexity of training\nCan be unclear as to basis for clustering\nAccuracy\n\n\n\n\n\n\nData usually partially labelled\nCombination of supervised and unsupervised\nMethods\n\nDeep Belief Networks (DBN) - based on stacked Restricted Boltzmann machines\n\n\n\n\n\n\nAgent - learning system\n\nobserves the environment - state\nmakes decisions\nperforms actions\nfeedback loop - penalties or rewards - aims to maximise rewards\n\nLearns a policy - a function that takes the state as an input feature vector and outputs an action that leads to the highest expected average reward\n\n\n\n\n\nSplit into batch (non-incremental) and online\n\n\n\nOffline - unable to learn incrementally from a data stream (usually due to complexity)\nSystem trained first then applied, without learning further unless it is taken offline and retrained\nCan be automated e.g. weekly\nHigh computational requirements\n\n\n\n\n\nTraining using small sequential chunks of data - streamed\nDoes not require storage of previous data\nLearning steps are of low complexity therefore can be performed on mobile systems\nCan also be used to process extremely large datasets as a stream\nLearning rate\n\nif high, will forget old data faster, sensitive to noise\nif low, inertia will be high, slower to learn, less sensitive to noise or outliers\n\nCorrupted or errors in the stream can affect the performance in real-time\n\npair with anomaly detection\n\n\n\n\n\n\nCan also categorise based on models of generalisation\n\n\n\nLearn from prior examples, then generalise to new data using a measure of similarity\n\n\n\n\n\nBuild or select a model from prior examples\nDefine a fitness function or cost function\nMinimise cost or maximise fitness, depending on the chosen model\nTrain the model on the training data to optimise parameters for a reasonable fit\nMake predictions\n\n\n\n\n\n\nBurkov, A. (2019) The Hundred-Page Machine Learning Book.\nGeron, A. (2017) Hands-On Machine Learning with Scikit-Learn & TensorFlow : concepts, tools, and techniques to build intelligent systems."
  },
  {
    "objectID": "posts/2022-04-19-ml-forms.html#supervision",
    "href": "posts/2022-04-19-ml-forms.html#supervision",
    "title": "Forms of ML",
    "section": "",
    "text": "In this classification, there are four main classes based on the amount or type of supervision\n\n\n\nData\n\nLabelled examples \\large{({\\bold x_i},y_i)_{i=1}^N}\n\\large x_i is a feature vector(\\large n-dimensional vector of numerical features \\large x^d)\n\nrepresent objects numerically e.g. for an image, \\large x^{(1)} could be the hue, and \\large x^{(2)} could be the intensity\nuseful for comparing objects e.g. euclidean distance\ngranularity depends on the purpose\n\n\\large y_i can take the form of a member of a set, real number, matrix, vector etc.\n\nTasks\n\nClassification e.g. spam filter\nPredict numeric values based on predictors (features) e.g. house price given room numbers and areas\n\nGoal\n\nTrain a model on a dataset to predict labels based on input feature vectors\n\nMethods\n\nLinear regression\nLogistic regression\nkNN\nSVM\nDT (& random forests)\nNeural networks\n\n\n\n\n\n\nData\n\nUnlabelled examples \\large{({\\bold x_i})_{i=1}^N}\n\\large x_i is a feature vector\n\nTasks\n\nClustering - group data points with shared attributes to extrapolate a relationship e.g. molecular structure similarity\nAnomaly/Outlier detection - find outliers e.g. fraud-detection\nRule learning\n\nGoal\n\nClustering - transform feature vector \\large \\bold x into a useful value e.g. an id\nDimensionality reduction - output feature vector should have fewer features than \\large \\bold x\nAnomaly/Outlier detection - output value quantifies the difference of \\large \\bold x from the data\n\nMethods\n\nClustering\n\nExclusive\n\nK-means\nHierarchical\n\nSoft - more probabilistic\n\nGMM\nExpectation Maximisation\n\n\nAssociation\n\nApriori\nEclat\n\nDimensionality reduction\n\nPCA\nSVD\nLLE\nt-SNE\n\n\nChallenges\n\nComputation and time complexity of training\nCan be unclear as to basis for clustering\nAccuracy\n\n\n\n\n\n\nData usually partially labelled\nCombination of supervised and unsupervised\nMethods\n\nDeep Belief Networks (DBN) - based on stacked Restricted Boltzmann machines\n\n\n\n\n\n\nAgent - learning system\n\nobserves the environment - state\nmakes decisions\nperforms actions\nfeedback loop - penalties or rewards - aims to maximise rewards\n\nLearns a policy - a function that takes the state as an input feature vector and outputs an action that leads to the highest expected average reward"
  },
  {
    "objectID": "posts/2022-04-19-ml-forms.html#incremental",
    "href": "posts/2022-04-19-ml-forms.html#incremental",
    "title": "Forms of ML",
    "section": "",
    "text": "Split into batch (non-incremental) and online\n\n\n\nOffline - unable to learn incrementally from a data stream (usually due to complexity)\nSystem trained first then applied, without learning further unless it is taken offline and retrained\nCan be automated e.g. weekly\nHigh computational requirements\n\n\n\n\n\nTraining using small sequential chunks of data - streamed\nDoes not require storage of previous data\nLearning steps are of low complexity therefore can be performed on mobile systems\nCan also be used to process extremely large datasets as a stream\nLearning rate\n\nif high, will forget old data faster, sensitive to noise\nif low, inertia will be high, slower to learn, less sensitive to noise or outliers\n\nCorrupted or errors in the stream can affect the performance in real-time\n\npair with anomaly detection"
  },
  {
    "objectID": "posts/2022-04-19-ml-forms.html#generalisability",
    "href": "posts/2022-04-19-ml-forms.html#generalisability",
    "title": "Forms of ML",
    "section": "",
    "text": "Can also categorise based on models of generalisation\n\n\n\nLearn from prior examples, then generalise to new data using a measure of similarity\n\n\n\n\n\nBuild or select a model from prior examples\nDefine a fitness function or cost function\nMinimise cost or maximise fitness, depending on the chosen model\nTrain the model on the training data to optimise parameters for a reasonable fit\nMake predictions"
  },
  {
    "objectID": "posts/2022-04-19-ml-forms.html#references",
    "href": "posts/2022-04-19-ml-forms.html#references",
    "title": "Forms of ML",
    "section": "",
    "text": "Burkov, A. (2019) The Hundred-Page Machine Learning Book.\nGeron, A. (2017) Hands-On Machine Learning with Scikit-Learn & TensorFlow : concepts, tools, and techniques to build intelligent systems."
  },
  {
    "objectID": "posts/2022-04-19-data-types.html",
    "href": "posts/2022-04-19-data-types.html",
    "title": "Data in ML",
    "section": "",
    "text": "Common taxonomy of data types when considering machine learning\n\nCategorical: qualitative\n\nOrdinal: innate ordered values with unknown distances between them that cannot be measured\n\ne.g. first/second/third, good/bad\n\nNominal: values (text or numbers) with no order\n\ne.g. cat/dog, genre, ethnicity\n\n\nNumerical: quantitative\n\nDiscrete: quantitative whole number values\n\ne.g. step count\n\nContinuous: quantitative decimal values\n\ne.g. width, height"
  },
  {
    "objectID": "posts/2022-04-19-data-types.html#footnotes",
    "href": "posts/2022-04-19-data-types.html#footnotes",
    "title": "Data in ML",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttp://economistjourney.blogspot.com/2018/06/what-is-sampling-noise.html.↩︎"
  },
  {
    "objectID": "posts/2022-02-05-matrices.html",
    "href": "posts/2022-02-05-matrices.html",
    "title": "Matrix Properties and Operations",
    "section": "",
    "text": "||\\boldsymbol{X}||{_F} = \\sqrt{\\displaystyle\\sum_{i,j} X_{i,j}{^2} }\nFor i rows, and j columns, sum the square of each element, then take the square root. This is analogous to the L^2 norm of vectors, and measures the Euclidean size of the matrix. Can also be thought of as the sum of the magnitude of all the vectors in \\boldsymbol{X}.\n\n\n\nNumber of columns in the first matrix must match the number of rows in the second, i.e. in the following example, m is the number of rows in the first matrix, n is the number of columns in the first matrix and the number of rows in the second, and p is the number of columns in the second matrix.\n m\\underset{n}{\\begin{bmatrix} \\, \\\\ A \\\\ \\,\\end{bmatrix}} \\quad\nn\\underset{p}{\\begin{bmatrix}& B &\\end{bmatrix}} = m\\underset{p}{\\begin{bmatrix} \\, \\\\ C \\\\ \\,\\end{bmatrix}}\n\n C_{i,k} = \\displaystyle\\sum_{j}A_{i,j}B_{j,k} \nMultiplying a matrix with a vector:\n\n\\begin{bmatrix} 3 & 4 \\\\ 5 & 6 \\\\ 7 & 8 \\end{bmatrix}\n\\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix} = \\begin{bmatrix} 3*1 + 4*2\\\\ 5*1+6*2 \\\\ 7*1+8*2 \\end{bmatrix} = \\begin{bmatrix} 11 \\\\ 17 \\\\ 23\\end{bmatrix}\n\nMultiplying a matrix with a matrix:\n\n\\begin{bmatrix} 3 & 4 \\\\ 5 & 6 \\\\ 7 & 8 \\end{bmatrix}\n\\begin{bmatrix} 1 & 9\\\\ 2 & 0 \\end{bmatrix} = \\begin{bmatrix} 3*1 + 4*2 & 3*9+4*0\\\\ 5*1+6*2 & 5*9+6*0\\\\ 7*1+8*2 &7*9+8*0 \\end{bmatrix} = \\begin{bmatrix} 11 & 27\\\\ 17 & 45\\\\ 23&63\\end{bmatrix}\n\nMatrix multiplication is typically not commutative: \\boldsymbol{X}\\boldsymbol{Y} \\not= \\boldsymbol{Y}\\boldsymbol{X}\nIf both matrices are square, multiplying either way will work, but the results will usually be different.\nCan represent the following regression as a matrix multiplication:\n\n\\begin{bmatrix}\ny{_1} |\\alpha + \\beta x{_{1,1}} + \\gamma x{_{1,2}} + ... + m_{-1}x{_{1,m_{-1}}} \\\\\ny{_2} | \\alpha + \\beta x{_{2,1}} + \\gamma x{_{2,2}} + ... + m_{-1}x{_{2,m_{-1}}} \\\\\n\\vdots \\\\\ny{_n} |  \\alpha + \\beta x{_{n,1}} + \\gamma x{_{n,2}} + ... + m_{-1}x{_{n,m_{-1}}}\n\\end{bmatrix} \\\\ \\begin{bmatrix} y{_1} \\\\ y{_2} \\\\ \\vdots \\\\ y{_n}\\end{bmatrix} =\\begin{bmatrix} 1 & X_{1,1} & X_{1,2} & \\dots & X_{1,m_{-1}}\\\\ 1 & X_{2,1} & X_{2,2} & \\dots & X_{2,m_{-1}} \\\\ \\vdots \\\\ 1 & X_{n,1} & X_{n,2} & \\dots & X_{n,m_{-1}} \\end{bmatrix}\n\\begin{bmatrix} \\alpha \\\\ \\beta \\\\ \\vdots \\\\ m_{-1}\\end{bmatrix}\n\nn cases tall, m features wide.\n\n\n\n\n\nNumber of rows = number of columns i.e. square Transpose is equal to itself i.e. any value on the diagonal but the values either side must be equal.\n\n\n\nAn identity matrix is a symmetric matrix where every element along the main diagonal is 1, all others are 0. This satisfies the condition of being an identity as, if an identity matrix is multiplied by a n length vector, it will remain unchanged i.e. we get the same vector returned.\nNotation \\boldsymbol{I}_n where n = height or width.\n1 is the identity element for multiplication - the number which when operated on with any other number results in the other number. 0 is the identity element for addition, and 1 is the identity element for multiplication. Whenever the identity element for an operation is the solution, the two items operated on are inverses of each other e.g. 5x = 15, both sides can be multiplied by the multiplicative inverse i.e. \\frac{1}{5} or 5^{-1} to get x=3. A number multiplied by its reciprocal or inverse always returns 1 e.g. \\frac{1}{5} * 5 = 1. Similarly, a matrix multiplied by its inverse, will return the identity matrix.\n\n\n\n\nUsed to computationally solve linear equations. Matrix inverse is denoted \\boldsymbol{X}^{-1}. It satisfies the following property:\n\\boldsymbol{X}^{-1} \\boldsymbol{X} = \\boldsymbol{X}\\boldsymbol{X}^{-1}  = \\boldsymbol{I}_n\n2x2 Matrix inversion: \n\\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix}^{-1} = \\frac{1}{ad-bc} \\begin{bmatrix} d & -b \\\\ -c & a \\end{bmatrix}\n\nwhere {ad-bc} is the determinant (which cannot be 0).\nCan’t divide by a matrix, but can multiply by an inverse to get the same result e.g. we know matrix \\boldsymbol{A} and \\boldsymbol{B}, and want to get the values for matrix \\boldsymbol{X}:\n\\boldsymbol{X} \\boldsymbol{A} = \\boldsymbol{B}\nWe can’t divide by \\boldsymbol{A}, but can multiply both sides by the inverse of \\boldsymbol{A}:\n$ ^{-1} = ^{-1}$ and we know that \\boldsymbol{A}\\boldsymbol{A}^{-1} = \\boldsymbol{I}\nwhich gives us\n$ = ^{-1}$\nand \\boldsymbol{I} can be ignored, just like 1 would be during multiplication:\n$ = ^{-1}$\nIf a matrix has no inverse i.e. the determinant is zero, then it is called singular.\nMatrix inversion can also only be calculated if the matrix is square i.e. the vector span (number of rows) is equal to the matrix range (number of cols). This avoids overdetermination (rows &gt; cols) i.e. number of equations &gt; number of dimensions (multiple points of overlap), and underdetermination (rows &lt; cols) i.e. number of equations are less than dimensions (no overlap as single line) - may still be able to solve these, but can’t invert a matrix as a solution.\n\n\n\n\\begin{bmatrix} y{_1} \\\\ y{_2} \\\\ \\vdots \\\\ y{_n}\\end{bmatrix} =\\begin{bmatrix} 1 & X_{1,1} & X_{1,2} & \\dots & X_{1,m_{-1}}\\\\ 1 & X_{2,1} & X_{2,2} & \\dots & X_{2,m_{-1}} \\\\ \\vdots \\\\ 1 & X_{n,1} & X_{n,2} & \\dots & X_{n,m_{-1}} \\end{bmatrix}\n\\begin{bmatrix} \\alpha \\\\ \\beta \\\\ \\vdots \\\\ m_{-1}\\end{bmatrix}\n Would like to solve for the vector of variables on the right, in this regression model. This can be represented as: \\boldsymbol{y} = \\boldsymbol{X}\\boldsymbol{w} where \\boldsymbol{w} is the vector of weights, \\alpha to m_{-1}, corresponding to the number of columns in our feature matrix.\nIn this equation, \\boldsymbol{y} = \\boldsymbol{X}\\boldsymbol{w}, we know the outcomes \\boldsymbol{y}, and we know the features \\boldsymbol{X}, and we wish to work out the weights, \\boldsymbol{w}, which we can do using matrix inversion, assuming the inverse matrix exists i.e. it isn’t singular - all columns must be linearly independent e.g. one column should not be a multiple of another one like [1,2] - another can’t be [2,4] or [1,2] again as we would have paralell lines or overlapping lines respectively.\nWe can multiply both sides by the inverse of \\boldsymbol{X}, \\boldsymbol{X}^{-1} to obtain:\n$^{-1} = ^{-1} $ and given \\boldsymbol{X}^{-1}\\boldsymbol{X} = \\boldsymbol{I}, we can simplify this to:\n$ = ^{-1} $ and given the property of the identity matrix, we can remove it to leave:\n$ = ^{-1} $\nThe order of operations is key to preserve, as matrix multiplication is not always commutative i.e. $ = $\n\n\n\nNon-zero elements along the main diagonal, zero elsewhere e.g. identity matrix. If it is square, denoted as diag(\\boldsymbol{x}) where \\boldsymbol{x} is a vector of main diagonal elements e.g. [1,1,1] to represent \\boldsymbol{I}_3. Much more computationally efficient: - Multiplication: diag(\\boldsymbol{x})\\boldsymbol{y} = \\boldsymbol{x}\\odot{}\\boldsymbol{y} - Inversion: $diag()^{-1} = diag(,,)^T $ - Can’t divide by zero, so if any elemenet along the diagonal contains zero, the diagonal can’t be inverted - Can be non-square and computation can still be efficient e.g. by adding zeros to the product if height &gt; width, or by removing elements from the product if the width &gt; height\n\n\n\nIn orthogonal matrices, orthonormal vectors make up all rows and columns. This means that \\boldsymbol{A}^{T} \\boldsymbol{A} = \\boldsymbol{A}\\boldsymbol{A}^{T}  = \\boldsymbol{I} and also that \\boldsymbol{A}^{T} = \\boldsymbol{A}^{-1}\\boldsymbol{I} = \\boldsymbol{A}^{-1}. Calculating \\boldsymbol{A}^{T} is cheap, and therefore so is \\boldsymbol{A}^{-1} for orthogonal matrices."
  },
  {
    "objectID": "posts/2022-02-05-matrices.html#norms---frobenius-norm",
    "href": "posts/2022-02-05-matrices.html#norms---frobenius-norm",
    "title": "Matrix Properties and Operations",
    "section": "",
    "text": "||\\boldsymbol{X}||{_F} = \\sqrt{\\displaystyle\\sum_{i,j} X_{i,j}{^2} }\nFor i rows, and j columns, sum the square of each element, then take the square root. This is analogous to the L^2 norm of vectors, and measures the Euclidean size of the matrix. Can also be thought of as the sum of the magnitude of all the vectors in \\boldsymbol{X}."
  },
  {
    "objectID": "posts/2022-02-05-matrices.html#multiplication",
    "href": "posts/2022-02-05-matrices.html#multiplication",
    "title": "Matrix Properties and Operations",
    "section": "",
    "text": "Number of columns in the first matrix must match the number of rows in the second, i.e. in the following example, m is the number of rows in the first matrix, n is the number of columns in the first matrix and the number of rows in the second, and p is the number of columns in the second matrix.\n m\\underset{n}{\\begin{bmatrix} \\, \\\\ A \\\\ \\,\\end{bmatrix}} \\quad\nn\\underset{p}{\\begin{bmatrix}& B &\\end{bmatrix}} = m\\underset{p}{\\begin{bmatrix} \\, \\\\ C \\\\ \\,\\end{bmatrix}}\n\n C_{i,k} = \\displaystyle\\sum_{j}A_{i,j}B_{j,k} \nMultiplying a matrix with a vector:\n\n\\begin{bmatrix} 3 & 4 \\\\ 5 & 6 \\\\ 7 & 8 \\end{bmatrix}\n\\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix} = \\begin{bmatrix} 3*1 + 4*2\\\\ 5*1+6*2 \\\\ 7*1+8*2 \\end{bmatrix} = \\begin{bmatrix} 11 \\\\ 17 \\\\ 23\\end{bmatrix}\n\nMultiplying a matrix with a matrix:\n\n\\begin{bmatrix} 3 & 4 \\\\ 5 & 6 \\\\ 7 & 8 \\end{bmatrix}\n\\begin{bmatrix} 1 & 9\\\\ 2 & 0 \\end{bmatrix} = \\begin{bmatrix} 3*1 + 4*2 & 3*9+4*0\\\\ 5*1+6*2 & 5*9+6*0\\\\ 7*1+8*2 &7*9+8*0 \\end{bmatrix} = \\begin{bmatrix} 11 & 27\\\\ 17 & 45\\\\ 23&63\\end{bmatrix}\n\nMatrix multiplication is typically not commutative: \\boldsymbol{X}\\boldsymbol{Y} \\not= \\boldsymbol{Y}\\boldsymbol{X}\nIf both matrices are square, multiplying either way will work, but the results will usually be different.\nCan represent the following regression as a matrix multiplication:\n\n\\begin{bmatrix}\ny{_1} |\\alpha + \\beta x{_{1,1}} + \\gamma x{_{1,2}} + ... + m_{-1}x{_{1,m_{-1}}} \\\\\ny{_2} | \\alpha + \\beta x{_{2,1}} + \\gamma x{_{2,2}} + ... + m_{-1}x{_{2,m_{-1}}} \\\\\n\\vdots \\\\\ny{_n} |  \\alpha + \\beta x{_{n,1}} + \\gamma x{_{n,2}} + ... + m_{-1}x{_{n,m_{-1}}}\n\\end{bmatrix} \\\\ \\begin{bmatrix} y{_1} \\\\ y{_2} \\\\ \\vdots \\\\ y{_n}\\end{bmatrix} =\\begin{bmatrix} 1 & X_{1,1} & X_{1,2} & \\dots & X_{1,m_{-1}}\\\\ 1 & X_{2,1} & X_{2,2} & \\dots & X_{2,m_{-1}} \\\\ \\vdots \\\\ 1 & X_{n,1} & X_{n,2} & \\dots & X_{n,m_{-1}} \\end{bmatrix}\n\\begin{bmatrix} \\alpha \\\\ \\beta \\\\ \\vdots \\\\ m_{-1}\\end{bmatrix}\n\nn cases tall, m features wide."
  },
  {
    "objectID": "posts/2022-02-05-matrices.html#symmetric-identity-matrices",
    "href": "posts/2022-02-05-matrices.html#symmetric-identity-matrices",
    "title": "Matrix Properties and Operations",
    "section": "",
    "text": "Number of rows = number of columns i.e. square Transpose is equal to itself i.e. any value on the diagonal but the values either side must be equal.\n\n\n\nAn identity matrix is a symmetric matrix where every element along the main diagonal is 1, all others are 0. This satisfies the condition of being an identity as, if an identity matrix is multiplied by a n length vector, it will remain unchanged i.e. we get the same vector returned.\nNotation \\boldsymbol{I}_n where n = height or width.\n1 is the identity element for multiplication - the number which when operated on with any other number results in the other number. 0 is the identity element for addition, and 1 is the identity element for multiplication. Whenever the identity element for an operation is the solution, the two items operated on are inverses of each other e.g. 5x = 15, both sides can be multiplied by the multiplicative inverse i.e. \\frac{1}{5} or 5^{-1} to get x=3. A number multiplied by its reciprocal or inverse always returns 1 e.g. \\frac{1}{5} * 5 = 1. Similarly, a matrix multiplied by its inverse, will return the identity matrix."
  },
  {
    "objectID": "posts/2022-02-05-matrices.html#matrix-inversion",
    "href": "posts/2022-02-05-matrices.html#matrix-inversion",
    "title": "Matrix Properties and Operations",
    "section": "",
    "text": "Used to computationally solve linear equations. Matrix inverse is denoted \\boldsymbol{X}^{-1}. It satisfies the following property:\n\\boldsymbol{X}^{-1} \\boldsymbol{X} = \\boldsymbol{X}\\boldsymbol{X}^{-1}  = \\boldsymbol{I}_n\n2x2 Matrix inversion: \n\\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix}^{-1} = \\frac{1}{ad-bc} \\begin{bmatrix} d & -b \\\\ -c & a \\end{bmatrix}\n\nwhere {ad-bc} is the determinant (which cannot be 0).\nCan’t divide by a matrix, but can multiply by an inverse to get the same result e.g. we know matrix \\boldsymbol{A} and \\boldsymbol{B}, and want to get the values for matrix \\boldsymbol{X}:\n\\boldsymbol{X} \\boldsymbol{A} = \\boldsymbol{B}\nWe can’t divide by \\boldsymbol{A}, but can multiply both sides by the inverse of \\boldsymbol{A}:\n$ ^{-1} = ^{-1}$ and we know that \\boldsymbol{A}\\boldsymbol{A}^{-1} = \\boldsymbol{I}\nwhich gives us\n$ = ^{-1}$\nand \\boldsymbol{I} can be ignored, just like 1 would be during multiplication:\n$ = ^{-1}$\nIf a matrix has no inverse i.e. the determinant is zero, then it is called singular.\nMatrix inversion can also only be calculated if the matrix is square i.e. the vector span (number of rows) is equal to the matrix range (number of cols). This avoids overdetermination (rows &gt; cols) i.e. number of equations &gt; number of dimensions (multiple points of overlap), and underdetermination (rows &lt; cols) i.e. number of equations are less than dimensions (no overlap as single line) - may still be able to solve these, but can’t invert a matrix as a solution.\n\n\n\n\\begin{bmatrix} y{_1} \\\\ y{_2} \\\\ \\vdots \\\\ y{_n}\\end{bmatrix} =\\begin{bmatrix} 1 & X_{1,1} & X_{1,2} & \\dots & X_{1,m_{-1}}\\\\ 1 & X_{2,1} & X_{2,2} & \\dots & X_{2,m_{-1}} \\\\ \\vdots \\\\ 1 & X_{n,1} & X_{n,2} & \\dots & X_{n,m_{-1}} \\end{bmatrix}\n\\begin{bmatrix} \\alpha \\\\ \\beta \\\\ \\vdots \\\\ m_{-1}\\end{bmatrix}\n Would like to solve for the vector of variables on the right, in this regression model. This can be represented as: \\boldsymbol{y} = \\boldsymbol{X}\\boldsymbol{w} where \\boldsymbol{w} is the vector of weights, \\alpha to m_{-1}, corresponding to the number of columns in our feature matrix.\nIn this equation, \\boldsymbol{y} = \\boldsymbol{X}\\boldsymbol{w}, we know the outcomes \\boldsymbol{y}, and we know the features \\boldsymbol{X}, and we wish to work out the weights, \\boldsymbol{w}, which we can do using matrix inversion, assuming the inverse matrix exists i.e. it isn’t singular - all columns must be linearly independent e.g. one column should not be a multiple of another one like [1,2] - another can’t be [2,4] or [1,2] again as we would have paralell lines or overlapping lines respectively.\nWe can multiply both sides by the inverse of \\boldsymbol{X}, \\boldsymbol{X}^{-1} to obtain:\n$^{-1} = ^{-1} $ and given \\boldsymbol{X}^{-1}\\boldsymbol{X} = \\boldsymbol{I}, we can simplify this to:\n$ = ^{-1} $ and given the property of the identity matrix, we can remove it to leave:\n$ = ^{-1} $\nThe order of operations is key to preserve, as matrix multiplication is not always commutative i.e. $ = $\n\n\n\nNon-zero elements along the main diagonal, zero elsewhere e.g. identity matrix. If it is square, denoted as diag(\\boldsymbol{x}) where \\boldsymbol{x} is a vector of main diagonal elements e.g. [1,1,1] to represent \\boldsymbol{I}_3. Much more computationally efficient: - Multiplication: diag(\\boldsymbol{x})\\boldsymbol{y} = \\boldsymbol{x}\\odot{}\\boldsymbol{y} - Inversion: $diag()^{-1} = diag(,,)^T $ - Can’t divide by zero, so if any elemenet along the diagonal contains zero, the diagonal can’t be inverted - Can be non-square and computation can still be efficient e.g. by adding zeros to the product if height &gt; width, or by removing elements from the product if the width &gt; height\n\n\n\nIn orthogonal matrices, orthonormal vectors make up all rows and columns. This means that \\boldsymbol{A}^{T} \\boldsymbol{A} = \\boldsymbol{A}\\boldsymbol{A}^{T}  = \\boldsymbol{I} and also that \\boldsymbol{A}^{T} = \\boldsymbol{A}^{-1}\\boldsymbol{I} = \\boldsymbol{A}^{-1}. Calculating \\boldsymbol{A}^{T} is cheap, and therefore so is \\boldsymbol{A}^{-1} for orthogonal matrices."
  },
  {
    "objectID": "posts/2022-04-30-linear-algebra-intro.html",
    "href": "posts/2022-04-30-linear-algebra-intro.html",
    "title": "Introduction to Linear Algebra",
    "section": "",
    "text": "Linear algebra deals with linear equations (no polynomial terms). However, it can still be used for approximations for non-linear systems. Uses in ML include solving for unknowns e.g. deep learning, dimensionality reduction e.g. PCA, ranking e.g. eigenvectors, associated recommendations and NLP e.g. SVD or matrix factorisation.\nAn example linear equation with many unknowns in a regression model of house prices:\n\\large y = \\alpha + \\beta x{_1} + \\gamma x{_2} + ... + mx{_m}\ny = price, \\alpha = y-intercept, \\beta = number of rooms, \\gamma = area, x = feature\nWhen dealing with linear systems of equations, there can only be three types of solutions, none, one or infinite. Plotting the equations, if the lines are parallel, they will never intersect i.e. no solution, if the lines are overlapping, there are infinite solutions, else the lines will intersect at one point only (it is impossible for straight lines to intersect multiple times).\nUsing the house price regression model, we will have as many rows(n) of these equations as we have house prices, each with its m_{-1} features(x) (m-1 due to alpha), and m+1 unknowns(\\alpha,\\beta, \\gamma) which is what we want to solve for:\n y = \\alpha + \\beta x{_1} + \\gamma x{_2} + ... + m_{-1}x_{m_{-1}} \n\n\\begin{bmatrix}\ny{_1} |\\alpha + \\beta x{_{1,1}} + \\gamma x{_{1,2}} + ... + m_{-1}x{_{1,m_{-1}}} \\\\\ny{_2} | \\alpha + \\beta x{_{2,1}} + \\gamma x{_{2,2}} + ... + m_{-1}x{_{2,m_{-1}}} \\\\\n\\dots \\\\\ny{_n} |  \\alpha + \\beta x{_{n,1}} + \\gamma x{_{n,2}} + ... + m_{-1}x{_{n,m_{-1}}}\n\\end{bmatrix}\n\nThis is a set (denoted by square brackets) of linear equations.\n\n\nTensors are a generalisation of vectors and matrices to any number of dimensions.\n\n\n\nDimension\nName\nDescription\n\n\n\n\n0\nScalar\nmagnitude (value)\n\n\n1\nVector\narray\n\n\n2\nMatrix\n2d array (square)\n\n\n3\n3-Tensor\n3d array (cube)\n\n\nn\nn-Tensor\nmultidimensional\n\n\n\n\n\nSingle value, no dimensions, denoted by lower case italic variable names e.g. x\n\n\n\n1-Dimensional ordered array of values, lower case bold italic name e.g. \\large \\boldsymbol{x}\nElements are scalars, denoted non-bold lower case x with their index e.g. x{_1}\n\n\n\\begin{bmatrix}  x{_1} & x{_2} & x{_3} \\end{bmatrix}{^T} = $\n\\begin{bmatrix}\nx{_1} \\\\\nx{_2} \\\\\nx{_3}\n\\end{bmatrix}\n$\nRow vector of shape (1,3) transposed to a column vector shape (3,1).\n\n\n\nNorms are functions that quantify vector magnitude (length).\n\\begin{bmatrix}  x{_1} & x{_2} \\end{bmatrix} = \\begin{bmatrix}  5 & 7 \\end{bmatrix} also represents a magnitude and direction from the origin.\n\\large L{^2} Norm ||\\boldsymbol{x}||{_2} = \\sqrt{\\sum_{\\substack{i}}x{_i}{^2}}\nSquare each element in the vector, sum them, then take the square root. Measures euclidean distance from the origin. Also commonly denoted \\large||\\boldsymbol{x}||.\n\\large L{^1} Norm ||\\boldsymbol{x}||{_1} = \\sum_{\\substack{i}}|x{_i}|\nSum the absolute values in the vector. Varies linearly at all locations (not origin dependent). Used when differences between zero and non-zero are needed.\nSquared \\large  L{^2} Norm ||\\boldsymbol{x}||{_2^2} = \\sum_{\\substack{i}}x{_i}{^2}\nSimilar to \\large L{^2} Norm, except we don’t take the root, just return the squared value. Computationally cheaper than \\large L{^2} Norm as sqaured \\large L{^2} Norm = \\boldsymbol{x}{^T}\\boldsymbol{x}. Derivative of element x only requires that element, vs \\large L{^2} Norm which requires the vector. However, squared \\large  L{^2} Norm grows slowly near the origin so can’t be used if zero/near-zero distinguishing is required.\n\\large L{^\\infin} Norm (or Max Norm) ||\\boldsymbol{x}||{_\\infin} = max{_i}|x{_i}|\nReturn maximum absolute value of the vector.\nGeneralised \\large L{^p} Norm ||\\boldsymbol{x}||{_p} = (\\sum_{\\substack{i}}|x{_i}|{^p}){^\\frac{1}{p}} for p being a real number \\geqslant 1\nNorms, particularly \\large L{^1} and \\large L{^2} norms, are used to regularise objective functions\n\n\n\nUnit vector is a special case where the L2 norm (length) is equal to one i.e. \\boldsymbol{x} is a unit vector with unit norm. \\large||\\boldsymbol{x}|| = 1\n\n\n\nBasis vectors are vectors that can be scaled to represent any vector in a given vector space, typically unit vectors are used along the axes of the vector space. For example, the basis vectors i = (1,0) and j=(0,1), then we can represent a vector \\boldsymbol v as follows: \\boldsymbol v = 0.5 i + 3j\n\n\n\nSets of vectors where the dot product of the vectors are zero: \\boldsymbol{x}{^T}\\boldsymbol{y} = 0 i.e. assuming they are of non-zero length, they are at 90\\degree angles i.e. perpendicular. For an n-dimensional space, there are a maximum of n mutually orthogonal vectors.\n\n\nOrthonormal vectors are orthogonal and have unit norm e.g. basis vectors.\n\n\n\n\n\nDenoted uppercase, italics and bold \\boldsymbol X = \\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix}\nNotation is (n_{row},n_{col})\nIndividual scalar elements denoted upper case italics only, e.g. \\boldsymbol X = \\begin{bmatrix} X_{1,1} & X_{1,2} \\\\ X_{2,1} & X_{2,2} \\end{bmatrix}\n\n\n\nUpper-case, bold, italic, sans-serif font e.g. 𝙓 For a 4-tensor 𝙓, an element at position (i,j,k,l) would be denoted as 𝙓_{(i,j,k,l)}"
  },
  {
    "objectID": "posts/2022-04-30-linear-algebra-intro.html#tensors",
    "href": "posts/2022-04-30-linear-algebra-intro.html#tensors",
    "title": "Introduction to Linear Algebra",
    "section": "",
    "text": "Tensors are a generalisation of vectors and matrices to any number of dimensions.\n\n\n\nDimension\nName\nDescription\n\n\n\n\n0\nScalar\nmagnitude (value)\n\n\n1\nVector\narray\n\n\n2\nMatrix\n2d array (square)\n\n\n3\n3-Tensor\n3d array (cube)\n\n\nn\nn-Tensor\nmultidimensional\n\n\n\n\n\nSingle value, no dimensions, denoted by lower case italic variable names e.g. x\n\n\n\n1-Dimensional ordered array of values, lower case bold italic name e.g. \\large \\boldsymbol{x}\nElements are scalars, denoted non-bold lower case x with their index e.g. x{_1}\n\n\n\\begin{bmatrix}  x{_1} & x{_2} & x{_3} \\end{bmatrix}{^T} = $\n\\begin{bmatrix}\nx{_1} \\\\\nx{_2} \\\\\nx{_3}\n\\end{bmatrix}\n$\nRow vector of shape (1,3) transposed to a column vector shape (3,1).\n\n\n\nNorms are functions that quantify vector magnitude (length).\n\\begin{bmatrix}  x{_1} & x{_2} \\end{bmatrix} = \\begin{bmatrix}  5 & 7 \\end{bmatrix} also represents a magnitude and direction from the origin.\n\\large L{^2} Norm ||\\boldsymbol{x}||{_2} = \\sqrt{\\sum_{\\substack{i}}x{_i}{^2}}\nSquare each element in the vector, sum them, then take the square root. Measures euclidean distance from the origin. Also commonly denoted \\large||\\boldsymbol{x}||.\n\\large L{^1} Norm ||\\boldsymbol{x}||{_1} = \\sum_{\\substack{i}}|x{_i}|\nSum the absolute values in the vector. Varies linearly at all locations (not origin dependent). Used when differences between zero and non-zero are needed.\nSquared \\large  L{^2} Norm ||\\boldsymbol{x}||{_2^2} = \\sum_{\\substack{i}}x{_i}{^2}\nSimilar to \\large L{^2} Norm, except we don’t take the root, just return the squared value. Computationally cheaper than \\large L{^2} Norm as sqaured \\large L{^2} Norm = \\boldsymbol{x}{^T}\\boldsymbol{x}. Derivative of element x only requires that element, vs \\large L{^2} Norm which requires the vector. However, squared \\large  L{^2} Norm grows slowly near the origin so can’t be used if zero/near-zero distinguishing is required.\n\\large L{^\\infin} Norm (or Max Norm) ||\\boldsymbol{x}||{_\\infin} = max{_i}|x{_i}|\nReturn maximum absolute value of the vector.\nGeneralised \\large L{^p} Norm ||\\boldsymbol{x}||{_p} = (\\sum_{\\substack{i}}|x{_i}|{^p}){^\\frac{1}{p}} for p being a real number \\geqslant 1\nNorms, particularly \\large L{^1} and \\large L{^2} norms, are used to regularise objective functions\n\n\n\nUnit vector is a special case where the L2 norm (length) is equal to one i.e. \\boldsymbol{x} is a unit vector with unit norm. \\large||\\boldsymbol{x}|| = 1\n\n\n\nBasis vectors are vectors that can be scaled to represent any vector in a given vector space, typically unit vectors are used along the axes of the vector space. For example, the basis vectors i = (1,0) and j=(0,1), then we can represent a vector \\boldsymbol v as follows: \\boldsymbol v = 0.5 i + 3j\n\n\n\nSets of vectors where the dot product of the vectors are zero: \\boldsymbol{x}{^T}\\boldsymbol{y} = 0 i.e. assuming they are of non-zero length, they are at 90\\degree angles i.e. perpendicular. For an n-dimensional space, there are a maximum of n mutually orthogonal vectors.\n\n\nOrthonormal vectors are orthogonal and have unit norm e.g. basis vectors.\n\n\n\n\n\nDenoted uppercase, italics and bold \\boldsymbol X = \\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix}\nNotation is (n_{row},n_{col})\nIndividual scalar elements denoted upper case italics only, e.g. \\boldsymbol X = \\begin{bmatrix} X_{1,1} & X_{1,2} \\\\ X_{2,1} & X_{2,2} \\end{bmatrix}\n\n\n\nUpper-case, bold, italic, sans-serif font e.g. 𝙓 For a 4-tensor 𝙓, an element at position (i,j,k,l) would be denoted as 𝙓_{(i,j,k,l)}"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Notes from my studies and interests. This is a work in progress and is constantly under refinement."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "notes",
    "section": "",
    "text": "Introduction to Linked Lists\n\n\n\n\n\n\nDSA\n\n\ndata-structures\n\n\nintroduction\n\n\nlinked-lists\n\n\npython\n\n\n\nLinked Lists Introduction\n\n\n\n\n\nAug 27, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nDivision Based Hash Functions\n\n\n\n\n\n\nDSA\n\n\ndata-structures\n\n\nintroduction\n\n\nprime-numbers\n\n\nhash-functions\n\n\n\nData Structures and Algorithms - Division Based Hash Functions\n\n\n\n\n\nAug 26, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to Basic Data Structures\n\n\n\n\n\n\nDSA\n\n\ndata structures\n\n\nintroduction\n\n\n\nData Structures and Algorithms - Basic Data Structures\n\n\n\n\n\nAug 24, 2024\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to CEGIS\n\n\n\n\n\n\nprogram-synthesis\n\n\nCEGIS\n\n\nintroduction\n\n\n\nNotes about counter example guided inductive programsynthesis\n\n\n\n\n\nApr 6, 2023\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to Functional Programming In Python\n\n\n\n\n\n\nprogramming\n\n\nfunctional-programming\n\n\nintroduction\n\n\npython\n\n\n\nNotes about functional programming in python\n\n\n\n\n\nApr 5, 2023\n\n\n\n\n\n\n\n\n\n\n\n\nInductive Program Synthesis\n\n\n\n\n\n\nprogramming\n\n\ninductive-synthesis\n\n\nalgorithm\n\n\n\nNotes about inductive program synthesis\n\n\n\n\n\nApr 3, 2023\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to Program Synthesis\n\n\n\n\n\n\nprogramming\n\n\nintroduction\n\n\nprogram-synthesis\n\n\n\nNotes about basic terms and concepts\n\n\n\n\n\nApr 1, 2023\n\n\n\n\n\n\n\n\n\n\n\n\nIntroduction to Linear Algebra\n\n\n\n\n\n\nmath\n\n\nlinear-algebra\n\n\nintroduction\n\n\n\nIntroduction and basic concepts of linear algebra\n\n\n\n\n\nApr 30, 2022\n\n\n\n\n\n\n\n\n\n\n\n\nEigenvectors and Eigenvalues\n\n\n\n\n\n\nmath\n\n\nlinear-algebra\n\n\neigenvectors\n\n\neigenvalues\n\n\nintroduction\n\n\n\nEigenvectors and Eigenvalues\n\n\n\n\n\nApr 30, 2022\n\n\n\n\n\n\n\n\n\n\n\n\nBasic Linear Algebra Concepts\n\n\n\n\n\n\njupyter\n\n\nmaths\n\n\nlinear-algebra\n\n\ntensors\n\n\nmatrices\n\n\n\nExamining some basic concepts of liner algebra using python libraries\n\n\n\n\n\nApr 30, 2022\n\n\n\n\n\n\n\n\n\n\n\n\nTensors and Tensor Operations\n\n\n\n\n\n\nmath\n\n\nlinear-algebra\n\n\ntensors\n\n\n\nTensors\n\n\n\n\n\nApr 30, 2022\n\n\n\n\n\n\n\n\n\n\n\n\nTraining, Testing, Validation Datasets and Cross-Validation\n\n\n\n\n\n\ndata\n\n\nML\n\n\ntraining\n\n\ntesting\n\n\nvalidation\n\n\ncross-validation\n\n\n\nDefining the concepts of testing, training and validation sets\n\n\n\n\n\nApr 27, 2022\n\n\n\n\n\n\n\n\n\n\n\n\nData in ML\n\n\n\n\n\n\ndata\n\n\nmaths\n\n\nstatistics\n\n\nML\n\n\n\nData Types, Quality & Quantity\n\n\n\n\n\nApr 19, 2022\n\n\n\n\n\n\n\n\n\n\n\n\nFeature Scaling in ML\n\n\n\n\n\n\ndata\n\n\nmaths\n\n\nstatistics\n\n\nML\n\n\nfeature-scaling\n\n\n\nRescaling, normalisation, standardisation\n\n\n\n\n\nApr 19, 2022\n\n\n\n\n\n\n\n\n\n\n\n\nForms of ML\n\n\n\n\n\n\ndata\n\n\nmaths\n\n\nstatistics\n\n\nML\n\n\n\nML types\n\n\n\n\n\nApr 19, 2022\n\n\n\n\n\n\n\n\n\n\n\n\nMaths for ML\n\n\n\n\n\n\nmath\n\n\nlinear-algebra\n\n\nstatistics\n\n\ncalculus\n\n\n\nLinks to notes for maths for ML\n\n\n\n\n\nApr 18, 2022\n\n\n\n\n\n\n\n\n\n\n\n\nMatrix Properties and Operations\n\n\n\n\n\n\nmath\n\n\nlinear-algebra\n\n\nmatrix\n\n\nintroduction\n\n\n\nMatrix properties and Operations\n\n\n\n\n\nFeb 5, 2022\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/2023-04-05-functional-programming-python.html",
    "href": "posts/2023-04-05-functional-programming-python.html",
    "title": "Introduction to Functional Programming In Python",
    "section": "",
    "text": "Python functions can take functions as arguments and can return functions to their calling site.\n\ndef inside():\n    print(\"This is inside\")\n\ndef outside(function):\n    function()\noutside(inside)\n\nThis is inside\n\n\nInner functions can sometimes be referred to as callbacks as they are not invoked immediately. Forexample, passing a custom function to sorted():\n\nfruits = [\"apple\", \"tomato\", \"pear\", \"blueberry\"]\n\ndef reverse_length(x):\n    return -len(x)\n\nprint(sorted(fruits, key=reverse_length))\n\n['blueberry', 'tomato', 'apple', 'pear']\n\n\nFunctions can also return functions, which can be called without intermediate assignement:\n\ndef inside():\n    print(\"This is inside\")\n\ndef outside(function):\n    return function\noutside(inside)()\n\nThis is inside\n\n\nLambda expressions can be useful and take the following form:\nlambda &lt;parameter_list (optional)&gt;: &lt;expression&gt;\nLambda expressions have their own namespace, and can access but not modify global variables. For example:\n\nreverse = lambda x: x[::-1]\ncallable(reverse)\nprint(reverse(\"Hello World!\"))\nprint(reverse([1,2,3,4]))\n\nprint((lambda x1, x2: x1+x2)(2,2))\n\nmeaning_of_life = lambda: 42\nprint(meaning_of_life())\n\n!dlroW olleH\n[4, 3, 2, 1]\n4\n42\n\n\nThe return value of a lambda can only be a single expression, and not assignemnet or return statements, or other control constructs. It also does not allow implicit tuple unpacking. Tuples, lists and dictionaries can still be returned, but reqiore explicit parentheses:\n\nprint((lambda x: (x, x**2, x**3))(2))\nprint((lambda x: [x, x**2, x**3])(2))\nprint((lambda x: {1:x, 2:x**2, 3:x**3})(2))\n\n(2, 4, 8)\n[2, 4, 8]\n{1: 2, 2: 4, 3: 8}\n\n\n\n\n\nMap can apply a function to each element of an iterable, and can return an iterator which can yield the results. Map takes the following form\nmap(&lt;function&gt;, &lt;iterable&gt;)\n\nsquare = lambda x: x**2\nnumbers = [1,2,3,4,5,6,7]\niterable = map(square, numbers)\nprint(next(iterable))\nprint(next(iterable))\nprint(next(iterable))\nprint(list(iterable))\n\n1\n4\n9\n[16, 25, 36, 49]\n\n\nIterating over the iterable yeilds the items.\nMap can also take the form map(&lt;function&gt;, &lt;iterable$_1$&gt;)"
  },
  {
    "objectID": "posts/2023-04-05-functional-programming-python.html#basic-syntax",
    "href": "posts/2023-04-05-functional-programming-python.html#basic-syntax",
    "title": "Introduction to Functional Programming In Python",
    "section": "",
    "text": "Python functions can take functions as arguments and can return functions to their calling site.\n\ndef inside():\n    print(\"This is inside\")\n\ndef outside(function):\n    function()\noutside(inside)\n\nThis is inside\n\n\nInner functions can sometimes be referred to as callbacks as they are not invoked immediately. Forexample, passing a custom function to sorted():\n\nfruits = [\"apple\", \"tomato\", \"pear\", \"blueberry\"]\n\ndef reverse_length(x):\n    return -len(x)\n\nprint(sorted(fruits, key=reverse_length))\n\n['blueberry', 'tomato', 'apple', 'pear']\n\n\nFunctions can also return functions, which can be called without intermediate assignement:\n\ndef inside():\n    print(\"This is inside\")\n\ndef outside(function):\n    return function\noutside(inside)()\n\nThis is inside\n\n\nLambda expressions can be useful and take the following form:\nlambda &lt;parameter_list (optional)&gt;: &lt;expression&gt;\nLambda expressions have their own namespace, and can access but not modify global variables. For example:\n\nreverse = lambda x: x[::-1]\ncallable(reverse)\nprint(reverse(\"Hello World!\"))\nprint(reverse([1,2,3,4]))\n\nprint((lambda x1, x2: x1+x2)(2,2))\n\nmeaning_of_life = lambda: 42\nprint(meaning_of_life())\n\n!dlroW olleH\n[4, 3, 2, 1]\n4\n42\n\n\nThe return value of a lambda can only be a single expression, and not assignemnet or return statements, or other control constructs. It also does not allow implicit tuple unpacking. Tuples, lists and dictionaries can still be returned, but reqiore explicit parentheses:\n\nprint((lambda x: (x, x**2, x**3))(2))\nprint((lambda x: [x, x**2, x**3])(2))\nprint((lambda x: {1:x, 2:x**2, 3:x**3})(2))\n\n(2, 4, 8)\n[2, 4, 8]\n{1: 2, 2: 4, 3: 8}"
  },
  {
    "objectID": "posts/2023-04-05-functional-programming-python.html#map",
    "href": "posts/2023-04-05-functional-programming-python.html#map",
    "title": "Introduction to Functional Programming In Python",
    "section": "",
    "text": "Map can apply a function to each element of an iterable, and can return an iterator which can yield the results. Map takes the following form\nmap(&lt;function&gt;, &lt;iterable&gt;)\n\nsquare = lambda x: x**2\nnumbers = [1,2,3,4,5,6,7]\niterable = map(square, numbers)\nprint(next(iterable))\nprint(next(iterable))\nprint(next(iterable))\nprint(list(iterable))\n\n1\n4\n9\n[16, 25, 36, 49]\n\n\nIterating over the iterable yeilds the items.\nMap can also take the form map(&lt;function&gt;, &lt;iterable$_1$&gt;)"
  },
  {
    "objectID": "posts/2022-04-18-maths-for-ml.html",
    "href": "posts/2022-04-18-maths-for-ml.html",
    "title": "Maths for ML",
    "section": "",
    "text": "Links to my notes on learning maths for ML.\n\n\n\n\n\nIntroduction & Notation\nMatrices\nTensors\nEigenvectors\n\nCh 1-7 Strang 1 Ch 2 Goodfellow 2\n\n\n\nCh 3 Goodfellow 3 Ch 1 Barber 4\n\n\n\nAppendix 2 Barber 5"
  },
  {
    "objectID": "posts/2022-04-18-maths-for-ml.html#topics",
    "href": "posts/2022-04-18-maths-for-ml.html#topics",
    "title": "Maths for ML",
    "section": "",
    "text": "Introduction & Notation\nMatrices\nTensors\nEigenvectors\n\nCh 1-7 Strang 1 Ch 2 Goodfellow 2\n\n\n\nCh 3 Goodfellow 3 Ch 1 Barber 4\n\n\n\nAppendix 2 Barber 5"
  },
  {
    "objectID": "posts/2022-04-18-maths-for-ml.html#footnotes",
    "href": "posts/2022-04-18-maths-for-ml.html#footnotes",
    "title": "Maths for ML",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nGilbert Strang. Introduction to linear algebra. Cambridge Press, Wellesley, MA, 2016.↩︎\nIan Goodfellow et Al. Deep learning. MIT press, 2016.↩︎\nIan Goodfellow et Al. Deep learning. MIT press, 2016.↩︎\nDavid Barber. Bayesian reasoning and machine learning. Cambridge University Press, 2012.↩︎\nDavid Barber. Bayesian reasoning and machine learning. Cambridge University Press, 2012.↩︎"
  },
  {
    "objectID": "posts/2022-04-19-feature-scaling.html",
    "href": "posts/2022-04-19-feature-scaling.html",
    "title": "Feature Scaling in ML",
    "section": "",
    "text": "For classifiers that calculate distances between points, e.g. Euclidean kNN or SVM, one feature can dominate the others purely due to scale when proportional contributions of all the features are wanted. Feature scaling (particularly standardisation) can also increase the convergence speed of gradient descent algorithms by altering the step size for each feature. Tree based algorithms and others (e.g. NB, LDA) are insensitive to the scale of the features as the decision to split at that node is not influenced by other features, rather the decision to split is usually based on what will decrease the variance or increase the homogeneity in the sub-nodes.\nGenerally, normalisation is applied when the distribution of the data is known to not be gaussian, e.g. for algorithms that do not presume a distribution e.g. kNN. It is important to consider outliers as normalising data with outliers will scale potentially important features into a small interval, so they must be handled first.\n\n\n\nPrevents the scale of the variable from over-influencing the model due to unit difference\nScale features or variables to a common scale without distortion of differences in the range\n\ne.g. [0,1]\n\nExamples\n\nRescaling (min-max normalisation) to a range of [0,1] or [-1,-1] or [a,b]\n\nx'= \\frac {x-min(x)} {max(x)-min(x)}\nx'= \\frac {(x-min(x))(b-a)} {max(x)-min(x)}\n\nMean normalisation\n\nx'= \\frac {x-average(x)} {max(x)-min(x)}\n\n\n\n\n\n\n\nStandardise to find out how many standard deviations the values have from the mean\nStandardisation will scale the data to have a mean of 0 and standard deviation of 1\nNo specific upper or lower bound of values\nMethods:\n\nZ-Score: for population mean and std.dev.\n\n\\LARGE z = \\frac{x - \\mu}{\\sigma}\n\nZ-Score (estimated): for sample mean and std.dev.(\\large S)\n\n\\LARGE z = \\frac{x - \\bar x}{S}\n\n\nUsages:\n\nStandardising regression coefficients\nStandardising variables prior to PCA\n\n\n\n\n\n\nScale the components of a feature vector such that the overall vector has length 1\ne.g. dividing by the Euclidean length of the vector\n\\large x'= \\frac {x} {||x||}\n\n\n\n\n\nWikipedia - Feature Scaling\nKDNuggets - Feature Scaling"
  },
  {
    "objectID": "posts/2022-04-19-feature-scaling.html#normalisation",
    "href": "posts/2022-04-19-feature-scaling.html#normalisation",
    "title": "Feature Scaling in ML",
    "section": "",
    "text": "Prevents the scale of the variable from over-influencing the model due to unit difference\nScale features or variables to a common scale without distortion of differences in the range\n\ne.g. [0,1]\n\nExamples\n\nRescaling (min-max normalisation) to a range of [0,1] or [-1,-1] or [a,b]\n\nx'= \\frac {x-min(x)} {max(x)-min(x)}\nx'= \\frac {(x-min(x))(b-a)} {max(x)-min(x)}\n\nMean normalisation\n\nx'= \\frac {x-average(x)} {max(x)-min(x)}"
  },
  {
    "objectID": "posts/2022-04-19-feature-scaling.html#standardisation",
    "href": "posts/2022-04-19-feature-scaling.html#standardisation",
    "title": "Feature Scaling in ML",
    "section": "",
    "text": "Standardise to find out how many standard deviations the values have from the mean\nStandardisation will scale the data to have a mean of 0 and standard deviation of 1\nNo specific upper or lower bound of values\nMethods:\n\nZ-Score: for population mean and std.dev.\n\n\\LARGE z = \\frac{x - \\mu}{\\sigma}\n\nZ-Score (estimated): for sample mean and std.dev.(\\large S)\n\n\\LARGE z = \\frac{x - \\bar x}{S}\n\n\nUsages:\n\nStandardising regression coefficients\nStandardising variables prior to PCA"
  },
  {
    "objectID": "posts/2022-04-19-feature-scaling.html#scaling-to-unit-length",
    "href": "posts/2022-04-19-feature-scaling.html#scaling-to-unit-length",
    "title": "Feature Scaling in ML",
    "section": "",
    "text": "Scale the components of a feature vector such that the overall vector has length 1\ne.g. dividing by the Euclidean length of the vector\n\\large x'= \\frac {x} {||x||}"
  },
  {
    "objectID": "posts/2022-04-19-feature-scaling.html#references",
    "href": "posts/2022-04-19-feature-scaling.html#references",
    "title": "Feature Scaling in ML",
    "section": "",
    "text": "Wikipedia - Feature Scaling\nKDNuggets - Feature Scaling"
  },
  {
    "objectID": "posts/2022-04-27-testing-validation.html",
    "href": "posts/2022-04-27-testing-validation.html",
    "title": "Training, Testing, Validation Datasets and Cross-Validation",
    "section": "",
    "text": "To build a mathematical model to make predictions, data is needed to train and test the model, for which three data sets are usually used. Typically, the data is split into a training set and testing set (80-20 or 70-30 etc.), or a training, testing and validation set. Cross-Validation can be particularly helpful for smaller datasets, helping to avoid over-fitting and hyperparameter tuning.\n\n\nDataset used to create a model to be used for predictions. The model can then be applied to the training data sets to assess the accuracy of predictions against labelled data. The model can then be tuned if necessary.\n\n\n\nThe model can then be applied to a testing set, data which has not been used to make the model, from which an error rate can be estimated (generalisation error).\nIf the training set error rate is low and the testing set error rate is high, it suggests the model has been over-fitted to the training data set.\n\n\n\nAnother holdout dataset can be used is the validation set. It provides an unbiased estimation of the performance of the model which can be useful when assessing multiple models to minimise over-fitting. Multiple models can be trained with different hyperparameters, and evaluated against the validation set, with the best performing hyperparameters and model being used on the test dataset to estimate the generalisation error. They can also be used to stop training early on a model where the error on the validation set increases beyond a specified limit.\n\n\n\nIf the dataset size is relatively smaller to begin with, to avoid issues with trying to train a model on less data, cross-validation can be used. The training dataset can be split up into subsets or subsamples. Each model can be trained against combinations of these and validated against the remaining ones. Then the final model can be trained, using the best performing hyperparameters, on the complete training set, so all observations have been used.\n\n\n\nK-folding\n\nSplit the data int k-subsets e.g. 3,5, 10 etc.\nBuild k models, each trained on k-1 and tested on the datasets they haven’t been trained on\n\nLeave p out\n\nUse p observations as the validation set, and the remaining as the training set\nThis is repeated for as many variations of sampling p elements out of the total observations\nif p&gt;1, this will mean training and validating C{n \\choose p} times, where n is the number of observations in the original sample\nif p=1, as in leave-one-out, this will mean training and validating C{n \\choose 1} times. If n is large, k-fold may be less computationally expensive.\n\nStratified k-fold\n\nEnsure that each fold is a representative sample of the whole population of observations e.g. mean is similar in all the subsets or proportions for binary classifiers\n\nRepeated random sub-sampling\n\nMonte Carlo cross validation - create multiple random training and validation subsets, then for each split, fit the model to the training subset and assess the accuracy on the validation subset. Then average the results over the subsets.\nValidation subsets may overlap, or some data points may never be used due to the random sampling.\nCan also be stratified by the mean of the subsets\n\n\n\n\n\n\n\nAny two optimisation algorithms are equivalent when their performance is averaged across all possible problems, if no assumptions are made about the data."
  },
  {
    "objectID": "posts/2022-04-27-testing-validation.html#training-set",
    "href": "posts/2022-04-27-testing-validation.html#training-set",
    "title": "Training, Testing, Validation Datasets and Cross-Validation",
    "section": "",
    "text": "Dataset used to create a model to be used for predictions. The model can then be applied to the training data sets to assess the accuracy of predictions against labelled data. The model can then be tuned if necessary."
  },
  {
    "objectID": "posts/2022-04-27-testing-validation.html#testing-set",
    "href": "posts/2022-04-27-testing-validation.html#testing-set",
    "title": "Training, Testing, Validation Datasets and Cross-Validation",
    "section": "",
    "text": "The model can then be applied to a testing set, data which has not been used to make the model, from which an error rate can be estimated (generalisation error).\nIf the training set error rate is low and the testing set error rate is high, it suggests the model has been over-fitted to the training data set."
  },
  {
    "objectID": "posts/2022-04-27-testing-validation.html#validation-set",
    "href": "posts/2022-04-27-testing-validation.html#validation-set",
    "title": "Training, Testing, Validation Datasets and Cross-Validation",
    "section": "",
    "text": "Another holdout dataset can be used is the validation set. It provides an unbiased estimation of the performance of the model which can be useful when assessing multiple models to minimise over-fitting. Multiple models can be trained with different hyperparameters, and evaluated against the validation set, with the best performing hyperparameters and model being used on the test dataset to estimate the generalisation error. They can also be used to stop training early on a model where the error on the validation set increases beyond a specified limit."
  },
  {
    "objectID": "posts/2022-04-27-testing-validation.html#cross-validation",
    "href": "posts/2022-04-27-testing-validation.html#cross-validation",
    "title": "Training, Testing, Validation Datasets and Cross-Validation",
    "section": "",
    "text": "If the dataset size is relatively smaller to begin with, to avoid issues with trying to train a model on less data, cross-validation can be used. The training dataset can be split up into subsets or subsamples. Each model can be trained against combinations of these and validated against the remaining ones. Then the final model can be trained, using the best performing hyperparameters, on the complete training set, so all observations have been used.\n\n\n\nK-folding\n\nSplit the data int k-subsets e.g. 3,5, 10 etc.\nBuild k models, each trained on k-1 and tested on the datasets they haven’t been trained on\n\nLeave p out\n\nUse p observations as the validation set, and the remaining as the training set\nThis is repeated for as many variations of sampling p elements out of the total observations\nif p&gt;1, this will mean training and validating C{n \\choose p} times, where n is the number of observations in the original sample\nif p=1, as in leave-one-out, this will mean training and validating C{n \\choose 1} times. If n is large, k-fold may be less computationally expensive.\n\nStratified k-fold\n\nEnsure that each fold is a representative sample of the whole population of observations e.g. mean is similar in all the subsets or proportions for binary classifiers\n\nRepeated random sub-sampling\n\nMonte Carlo cross validation - create multiple random training and validation subsets, then for each split, fit the model to the training subset and assess the accuracy on the validation subset. Then average the results over the subsets.\nValidation subsets may overlap, or some data points may never be used due to the random sampling.\nCan also be stratified by the mean of the subsets"
  },
  {
    "objectID": "posts/2022-04-27-testing-validation.html#no-free-lunch-theorem1",
    "href": "posts/2022-04-27-testing-validation.html#no-free-lunch-theorem1",
    "title": "Training, Testing, Validation Datasets and Cross-Validation",
    "section": "",
    "text": "Any two optimisation algorithms are equivalent when their performance is averaged across all possible problems, if no assumptions are made about the data."
  },
  {
    "objectID": "posts/2022-04-30-intro-to-linear-algebra.html",
    "href": "posts/2022-04-30-intro-to-linear-algebra.html",
    "title": "Basic Linear Algebra Concepts",
    "section": "",
    "text": "Intro to Linear Algebra\nReferences: 1. https://github.com/jonkrohn/ML-foundations\n\nimport numpy as np\nimport math\nimport torch\nimport tensorflow as tf\nimport matplotlib.pyplot as plt\n\nModuleNotFoundError: No module named 'torch'\n\n\n\nScalar Tensors\nPytorch tensors can be used for operations on the GPU or CPU, unlike numpy arrays, by casting the tensor to a CUDA data type.\nTensorflow tensors are also immutable, and created using wrappers.\n\n# Example scalar pytorch tensor\nx = torch.tensor(10, dtype=torch.int64)\nprint(f\"Type: {x.dtype}, Shape: {x.shape}\")\n\nType: torch.int64, Shape: torch.Size([])\n\n\n\n# Example scalar tensorflow tensor\nx = tf.constant(10, dtype=tf.int64)\nx\n\nNameError: name 'tf' is not defined\n\n\n\n\nVector Transposition\n\nx = np.array([[5,6,7]]) #Need extra brackets else shape will be (,3) (1D, not 2D)\nprint(f\"x = {x} \\nShape = {x.shape}\")\n\nx = [[5 6 7]] \nShape = (1, 3)\n\n\n\nx_t = x.T\nprint(f\"x transposed:\\n{x_t} \\nShape = {x_t.shape}\")\n\nx transposed:\n[[5]\n [6]\n [7]] \nShape = (3, 1)\n\n\n\nx = torch.tensor([5,6,7])\nprint(f\"x = {x} \\nShape = {x.shape}\")\n\nx = tensor([5, 6, 7]) \nShape = torch.Size([3])\n\n\n\n#L2 Norm - euclidean distance\nx = np.array([[5,6,7]])\nnp.linalg.norm(x)\n\n10.488088481701515\n\n\n\n# L1 Norm\nnp.sum(np.absolute(x))\n\n18\n\n\n\n# Squared L2 Norm\nx = np.array([5,6,7])\nnp.dot(x,x)\n\n110\n\n\n\n# Max norm\nnp.max(np.abs(x))\n\n7\n\n\n\n#Orthogonal\ni = np.asarray([1,0])\nj = np.asarray([0,1])\nnp.dot(i,j)\n\n0\n\n\n\n\nMatrices (2-Tensor)\n\nX = np.array([[5,3],[6,8],[2,10]])\nprint(f\"{X}\\n Shape: {X.shape} Size: {X.size}\")\n\n[[ 5  3]\n [ 6  8]\n [ 2 10]]\n Shape: (3, 2) Size: 6\n\n\n\nX[:,0] # left column\n\narray([5, 6, 2])\n\n\n\nX[1,:] # middle row\n\narray([6, 8])\n\n\n\n#pytorch\nX = torch.tensor([[5,3],[6,8],[2,10]])\nprint(f\"{X}\\n Shape: {X.shape}\")\n\ntensor([[ 5,  3],\n        [ 6,  8],\n        [ 2, 10]])\n Shape: torch.Size([3, 2])\n\n\n\n#Tensorflow\nX = tf.constant([[5,3],[6,8],[2,10]])\nprint(f\"Rank: {tf.rank(X)} Shape: {tf.shape(X)}\")\n\nRank: 2 Shape: [3 2]\n\n\n\n\nn-Tensors\n\nX = torch.zeros([5,2,4,2])\nX.shape\n\ntorch.Size([5, 2, 4, 2])\n\n\n\nX = tf.zeros([5,2,4,2])\nprint(f\"Rank: {tf.rank(X)}\")\n\nRank: 4\n\n\n\n\nTensor Operations\n\nX = np.array([[5,3],[6,8],[2,10]])\nprint(f\"X*2 = \\n{X*2}\\n  X+2 =\\n{X+2}\")\n\nX*2 = \n[[10  6]\n [12 16]\n [ 4 20]]\n  X+2 =\n[[ 7  5]\n [ 8 10]\n [ 4 12]]\n\n\n\nX = torch.tensor([[5,3],[6,8],[2,10]])\nprint(f\"X*2 = \\n{torch.mul(X,2)}\\n  X+2 =\\n{torch.add(X,2)}\")\n\nX*2 = \ntensor([[10,  6],\n        [12, 16],\n        [ 4, 20]])\n  X+2 =\ntensor([[ 7,  5],\n        [ 8, 10],\n        [ 4, 12]])\n\n\n\n\nElementwise Product\nIf tensors have the same size, operations can be aplied elementwise, this is the Hadamard product: \\boldsymbol X \\odot \\boldsymbol Y It produces a tensor that is the same shape as the input, unlike the dot product which will produce a scalar value.\n\nX = np.array([[5,3],[6,8],[2,10]])\nY = X + 5\nprint(X*Y) ##dot product, not matrix multiplication\n\n[[ 50  24]\n [ 66 104]\n [ 14 150]]\n\n\n\n\nTensor Reduction\n\nprint(X.sum(), torch.sum(torch.tensor([[5,3],[6,8],[2,10]])))\nprint(tf.reduce_sum(tf.constant([[5,3],[6,8],[2,10]])))\nprint(X.sum(axis=0), X.sum(axis=1)) #along specific axes\nprint(torch.sum(torch.tensor([[5,3],[6,8],[2,10]]),0))\nprint(torch.sum(torch.tensor([[5,3],[6,8],[2,10]]),1))\nprint(tf.reduce_sum(tf.constant([[5,3],[6,8],[2,10]]),0))\nprint(tf.reduce_sum(tf.constant([[5,3],[6,8],[2,10]]),1))\n\n34 tensor(34)\ntf.Tensor(34, shape=(), dtype=int32)\n[13 21] [ 8 14 12]\ntensor([13, 21])\ntensor([ 8, 14, 12])\ntf.Tensor([13 21], shape=(2,), dtype=int32)\ntf.Tensor([ 8 14 12], shape=(3,), dtype=int32)\n\n\n\n\nDot Product\nThe vectors must be of the same length or shape for the element-wise multiplication to occurr.\n\nX = np.array([5,3,6,8,2,10])\nY = X + 1\nprint(np.dot(X,Y))\n\n272\n\n\n\nprint(torch.dot(torch.tensor([5,3,6,8,2,10]),torch.add(torch.tensor([5,3,6,8,2,10]),1)))\n\ntensor(272)\n\n\n\nprint(tf.reduce_sum(tf.multiply(tf.constant([5,3,6,8,2,10]),tf.add(tf.constant([5,3,6,8,2,10]),1))))\n\ntf.Tensor(272, shape=(), dtype=int32)\n\n\n\n\n\nMatrices\n\nFrobenius Norm\n\nX = np.array([[5,3],[6,8],[2,10]])\nprint(np.linalg.norm(X))\nprint(torch.norm(torch.tensor([[5.,3],[6,8],[2,10]])))\nprint(tf.norm(tf.constant([[5.,3],[6,8],[2,10]])))\n\n15.427248620541512\ntensor(15.4272)\ntf.Tensor(15.427248, shape=(), dtype=float32)\n\n\n\n\nMatrix Multiplication\n\nA = np.array([[3,4],[5,6],[7,8]])\nb = np.array([1,2])\nprint(np.dot(A,b)) #infers dot product vs matrix multiplication based on shape\nC = torch.tensor([[3,4],[5,6],[7,8]])\nd = torch.tensor([1,2])\nprint(torch.matmul(C,d))\nE = tf.constant([[3,4],[5,6],[7,8]])\nf = tf.constant([1,2])\nprint(tf.linalg.matvec(E,f))\n\ntensor([11, 17, 23])\ntf.Tensor([11 17 23], shape=(3,), dtype=int32)\n\n\n\nA = np.array([[3,4],[5,6],[7,8]])\nb = np.array([[1,9],[2,0]])\nprint(np.dot(A,b)) \nC = torch.tensor([[3,4],[5,6],[7,8]])\nd = torch.tensor([[1,9],[2,0]])\nprint(torch.matmul(C,d))\nE = tf.convert_to_tensor(A)\nf = tf.convert_to_tensor(b)\nprint(tf.matmul(E,f))\n\n[[11 27]\n [17 45]\n [23 63]]\ntensor([[11, 27],\n        [17, 45],\n        [23, 63]])\ntf.Tensor(\n[[11 27]\n [17 45]\n [23 63]], shape=(3, 2), dtype=int64)\n\n\n\n\nMatrix Inversion\n\nX = np.array([[4,2],[-5,-3]])\nX_inv = np.linalg.inv(X)\ny = np.array([4,-7])\nprint(w:= np.dot(X_inv,y))\nprint(np.dot(X,w))\n\n[-1.  4.]\n[ 4. -7.]"
  },
  {
    "objectID": "posts/2023-04-01-introduction-program-synthesis.html",
    "href": "posts/2023-04-01-introduction-program-synthesis.html",
    "title": "Introduction to Program Synthesis",
    "section": "",
    "text": "Generally, compilers transform source code from the source language to the target language, usually to create an executable program, whereas program synthesisers search for a program that will satisfy some stated requirements. They both take high-level specifications to generate software, but synthesisers can search over a solution space to discover how to generate a program to satisfy the requirements (some compiler optimisations also do this e.g. autotuning). A program in this context, is a description of how to perform a computation. It is useful to constrain the solution to narrower notation than programming languages such as Domain Specific Languages (DSL) to avoid using specific constructs, rather build using a limited set of functions. Functional programming notation is useful for synthesis as we avoid side effects which can simplify the reasoning process, and can be expressed concisely.\n## Synthesis Program synthesis will generate a program that will solve the stated problem, within a specified program solution space i.e. with control over the space of programs, not just the intended behaviour. An example is flash fill (Excel) which derives and applies a small program to the rest of the data. The order can also be reversed e.g. start with a program and search for the specification i.e. reverse engineering e.g. Verified Lifting - discovering a high level representation that is provably equivalent to an implementation which can then be uo generate a more efficient version of the program. There are 3 major challenges; intention, invention and adaptation to consider.\n\n\n\nSemantic and syntactic constraints: form of user input will influence the synthesis system e.g. input-output examples like flash fill may not be suitable. May need a multimodal approach with some examples or abstract examples combined with logical specifications, to provide enough data about intended behaviour.\nUnder specification: if there are multiple solutions that satisfy requirements, which one should be chosen?\n\n\n\n\n\nDiscovering the code to satisfy the requirements\n\n\n\n\n\nThe application of synthesis to broader software development e.g. bug fixing, optimisation and other maintenance or existing codebase tasks.\n\n\n\n\n\nInductive synthesis generates a function that matches provided input-output examples. Deductive synthesis generally requires a complete list of axioms and formal specification for the language and program which may be difficult to obtain. Inductive synthesis allows for less complete specification with the downside of scaling issues due to iteration. ### Programming by example (PBE) and Programming by demonstration (PBD) In PBE, just the input-output is provided, which can leave a large potential solution space e.g. f(1) = 1 which could be addition, division, multiplication etc.\nIn PBD, a trace of the computation performed is also provided to provide additional specification which makes it easier to infer the intended program, e.g. f(1) = 1 \\times 1 = 1\nPBD and PBE can still be under-specificed with a large solution program space; need to address how to find the program that matches the observations, and how to know that the program that the user required is the one that was found. Arbritrary spaces can also be searched e.g. a large but highly constrained space, allowing exclusion of undesirable solutions, but would still likely require ranking of solutions.\n\n\n\nNeed to represent code as a data structure - Abstrac Syntax Trees (AST) are commonly used for this as they usually follow the same structure of the parse tree of the program, whilst ignoring additional characters e.g. parentheses, hence abstract. Context free grammar notation is often used to describe ASTs, to represent the structure of DSLs.\n\n\n\n\n\nExplicitly construct programs until one satisfies the observations, ideally avoiding the generation of programs that are not viable e.g. cannot satisfy the observations or can be proven redundant from existing found solutions. - Bottom-Up: discover low level components then ho to assemble them into programs i.e. leaf nodes up. - Top-Down: discover the high level structure first, then enumerate to the low level components i.e. root down. The synthesiser will maintain a partial or completely constructed program that is being evaluated e.g. would evaluate potential solutions until success. ### Symbolic Search In symbolic searching, the synthesiser will maintain a symbolic representation of the space of all programs that are considered valid e.g. Version Space Algebras and Constraint Systems. A symbolic search may perform some algebraeic manipulation to deduce results which may perform better in some cases, but not all e.g. binary search being effective in finding solutions where algebraeic manipulation may be too costly. ## Program Solution Space ### Small DSL One way to simplify the solution space is to define or use a small DSL, then consider all possible valid programs within this language, using context free grammar to describe the ASTs. This makes it simple to enumerate all (or randomly sample) programs in a small DSL. If the DSL has a type system, this can help eliminate solutions which violate type rules. ### Constraint Based Constraint based approaches utilise parametric representations of the space - different choices of paramters correspond to different forms of the program. Paramtetric representations can be more general than grammars - grammars can be encoded in paramteric representation provided a boundary on the length of the program. Paramteric programs can also be referred to as generative models, particularly when the free parameter choice is associated with probabilities. ### Symmetry If there are many ways to represent the same program, the program space has lots of symmetry. Symmetry can be reduced with reduction of cummtativity e.g. forcing right or left associativity. Constraint and enumeration based strategies can benefit from symmetry reduction, though there are additional techniques that are mostly removed from this issue. For example $expr := var N | expr + expr $ has a greater soltuion space than $expr := var N | (var * N) + expr $ which forces right associativity."
  },
  {
    "objectID": "posts/2023-04-01-introduction-program-synthesis.html#compilation-vs-synthesis",
    "href": "posts/2023-04-01-introduction-program-synthesis.html#compilation-vs-synthesis",
    "title": "Introduction to Program Synthesis",
    "section": "",
    "text": "Generally, compilers transform source code from the source language to the target language, usually to create an executable program, whereas program synthesisers search for a program that will satisfy some stated requirements. They both take high-level specifications to generate software, but synthesisers can search over a solution space to discover how to generate a program to satisfy the requirements (some compiler optimisations also do this e.g. autotuning). A program in this context, is a description of how to perform a computation. It is useful to constrain the solution to narrower notation than programming languages such as Domain Specific Languages (DSL) to avoid using specific constructs, rather build using a limited set of functions. Functional programming notation is useful for synthesis as we avoid side effects which can simplify the reasoning process, and can be expressed concisely.\n## Synthesis Program synthesis will generate a program that will solve the stated problem, within a specified program solution space i.e. with control over the space of programs, not just the intended behaviour. An example is flash fill (Excel) which derives and applies a small program to the rest of the data. The order can also be reversed e.g. start with a program and search for the specification i.e. reverse engineering e.g. Verified Lifting - discovering a high level representation that is provably equivalent to an implementation which can then be uo generate a more efficient version of the program. There are 3 major challenges; intention, invention and adaptation to consider.\n\n\n\nSemantic and syntactic constraints: form of user input will influence the synthesis system e.g. input-output examples like flash fill may not be suitable. May need a multimodal approach with some examples or abstract examples combined with logical specifications, to provide enough data about intended behaviour.\nUnder specification: if there are multiple solutions that satisfy requirements, which one should be chosen?\n\n\n\n\n\nDiscovering the code to satisfy the requirements\n\n\n\n\n\nThe application of synthesis to broader software development e.g. bug fixing, optimisation and other maintenance or existing codebase tasks."
  },
  {
    "objectID": "posts/2023-04-01-introduction-program-synthesis.html#inductive-synthesis",
    "href": "posts/2023-04-01-introduction-program-synthesis.html#inductive-synthesis",
    "title": "Introduction to Program Synthesis",
    "section": "",
    "text": "Inductive synthesis generates a function that matches provided input-output examples. Deductive synthesis generally requires a complete list of axioms and formal specification for the language and program which may be difficult to obtain. Inductive synthesis allows for less complete specification with the downside of scaling issues due to iteration. ### Programming by example (PBE) and Programming by demonstration (PBD) In PBE, just the input-output is provided, which can leave a large potential solution space e.g. f(1) = 1 which could be addition, division, multiplication etc.\nIn PBD, a trace of the computation performed is also provided to provide additional specification which makes it easier to infer the intended program, e.g. f(1) = 1 \\times 1 = 1\nPBD and PBE can still be under-specificed with a large solution program space; need to address how to find the program that matches the observations, and how to know that the program that the user required is the one that was found. Arbritrary spaces can also be searched e.g. a large but highly constrained space, allowing exclusion of undesirable solutions, but would still likely require ranking of solutions."
  },
  {
    "objectID": "posts/2023-04-01-introduction-program-synthesis.html#programming",
    "href": "posts/2023-04-01-introduction-program-synthesis.html#programming",
    "title": "Introduction to Program Synthesis",
    "section": "",
    "text": "Need to represent code as a data structure - Abstrac Syntax Trees (AST) are commonly used for this as they usually follow the same structure of the parse tree of the program, whilst ignoring additional characters e.g. parentheses, hence abstract. Context free grammar notation is often used to describe ASTs, to represent the structure of DSLs."
  },
  {
    "objectID": "posts/2023-04-01-introduction-program-synthesis.html#search-techniques",
    "href": "posts/2023-04-01-introduction-program-synthesis.html#search-techniques",
    "title": "Introduction to Program Synthesis",
    "section": "",
    "text": "Explicitly construct programs until one satisfies the observations, ideally avoiding the generation of programs that are not viable e.g. cannot satisfy the observations or can be proven redundant from existing found solutions. - Bottom-Up: discover low level components then ho to assemble them into programs i.e. leaf nodes up. - Top-Down: discover the high level structure first, then enumerate to the low level components i.e. root down. The synthesiser will maintain a partial or completely constructed program that is being evaluated e.g. would evaluate potential solutions until success. ### Symbolic Search In symbolic searching, the synthesiser will maintain a symbolic representation of the space of all programs that are considered valid e.g. Version Space Algebras and Constraint Systems. A symbolic search may perform some algebraeic manipulation to deduce results which may perform better in some cases, but not all e.g. binary search being effective in finding solutions where algebraeic manipulation may be too costly. ## Program Solution Space ### Small DSL One way to simplify the solution space is to define or use a small DSL, then consider all possible valid programs within this language, using context free grammar to describe the ASTs. This makes it simple to enumerate all (or randomly sample) programs in a small DSL. If the DSL has a type system, this can help eliminate solutions which violate type rules. ### Constraint Based Constraint based approaches utilise parametric representations of the space - different choices of paramters correspond to different forms of the program. Paramtetric representations can be more general than grammars - grammars can be encoded in paramteric representation provided a boundary on the length of the program. Paramteric programs can also be referred to as generative models, particularly when the free parameter choice is associated with probabilities. ### Symmetry If there are many ways to represent the same program, the program space has lots of symmetry. Symmetry can be reduced with reduction of cummtativity e.g. forcing right or left associativity. Constraint and enumeration based strategies can benefit from symmetry reduction, though there are additional techniques that are mostly removed from this issue. For example $expr := var N | expr + expr $ has a greater soltuion space than $expr := var N | (var * N) + expr $ which forces right associativity."
  },
  {
    "objectID": "posts/2023-04-06-CEGIS.html",
    "href": "posts/2023-04-06-CEGIS.html",
    "title": "Introduction to CEGIS",
    "section": "",
    "text": "Counter Example Guided Inductive Synthesis (CEGIS)\nIn CEGIS, with a supplied specification, a synthesiser produces a program that may satisfy the specification, and a verifier determines if this is true, otherwise it will provide a defined form of feedback to the synthesiser to further guide its search. The feedback is usually a counterexample - an input upon which the program did not satisfy the specification.\n\n\nReferences\n[^1] A. Solar-Lezama, MIT 6.S981 Introduction to Program Synthesis [^2] J. Bornholt 2015 Program Synthesis Explained"
  },
  {
    "objectID": "posts/2024-08-26-hash-functions-introduction.html",
    "href": "posts/2024-08-26-hash-functions-introduction.html",
    "title": "Division Based Hash Functions",
    "section": "",
    "text": "A simple modulus hash function can be defined as:\nh(x) = x \\mod n\nWhere x is the input value (key) and n is the number of buckets in the hash table. While n can be any positive integer, choosing a prime number for n can significantly reduce collisions, especially for certain types of input data.\n\n\nPrime numbers are particularly useful when the keys are of the form a + k \\times b, where a and b are constants and k varies. This pattern is common in many applications, such as memory addresses or sequential IDs.\nUsing a prime number for n helps to:\n\nReduce collisions\nEnsure a more uniform distribution of hash values\nMinimize the impact of patterns in the input data\n\n\n\n\nIf we have keys of the form 100 + k \\times 50, and we need to hash these into a table.\nCase 1: Non-prime number of buckets Using 100 buckets (non-prime).\nh(x) = x \\mod 100\nFor our keys:\n- h(100) = 0\n- h(150) = 50\n- h(200) = 0\n- h(250) = 50\n- h(300) = 0\nWe see that all keys hash to either 0 or 50, utilizing only 2 out of 100 buckets.\nCase 2: Prime number of buckets Now using 101 buckets (prime).\nh(x) = x \\mod 101\nFor the same keys:\n- h(100) = 100\n- h(150) = 48\n- h(200) = 99\n- h(250) = 47\n- h(300) = 98\nWe get a much better distribution, using 5 different buckets for our 5 keys.\n\n\n\nWhen n is not prime, it’s more likely to share factors with the step size in the key pattern (in our example, 50). This causes the hash values to repeat in a cycle much shorter than n.\nA prime n is less likely to share factors with the key pattern, ensuring that the hash values cycle through a larger portion of the available buckets before repeating.\n\n\n\nWhile using a prime number doesn’t guarantee perfect distribution or zero collisions, it significantly improves the hash function’s performance for many common types of input data (especially those with patterns or structures)."
  },
  {
    "objectID": "posts/2024-08-26-hash-functions-introduction.html#why-prime-numbers-are-used-in-division-based-hash-functions",
    "href": "posts/2024-08-26-hash-functions-introduction.html#why-prime-numbers-are-used-in-division-based-hash-functions",
    "title": "Division Based Hash Functions",
    "section": "",
    "text": "A simple modulus hash function can be defined as:\nh(x) = x \\mod n\nWhere x is the input value (key) and n is the number of buckets in the hash table. While n can be any positive integer, choosing a prime number for n can significantly reduce collisions, especially for certain types of input data.\n\n\nPrime numbers are particularly useful when the keys are of the form a + k \\times b, where a and b are constants and k varies. This pattern is common in many applications, such as memory addresses or sequential IDs.\nUsing a prime number for n helps to:\n\nReduce collisions\nEnsure a more uniform distribution of hash values\nMinimize the impact of patterns in the input data\n\n\n\n\nIf we have keys of the form 100 + k \\times 50, and we need to hash these into a table.\nCase 1: Non-prime number of buckets Using 100 buckets (non-prime).\nh(x) = x \\mod 100\nFor our keys:\n- h(100) = 0\n- h(150) = 50\n- h(200) = 0\n- h(250) = 50\n- h(300) = 0\nWe see that all keys hash to either 0 or 50, utilizing only 2 out of 100 buckets.\nCase 2: Prime number of buckets Now using 101 buckets (prime).\nh(x) = x \\mod 101\nFor the same keys:\n- h(100) = 100\n- h(150) = 48\n- h(200) = 99\n- h(250) = 47\n- h(300) = 98\nWe get a much better distribution, using 5 different buckets for our 5 keys.\n\n\n\nWhen n is not prime, it’s more likely to share factors with the step size in the key pattern (in our example, 50). This causes the hash values to repeat in a cycle much shorter than n.\nA prime n is less likely to share factors with the key pattern, ensuring that the hash values cycle through a larger portion of the available buckets before repeating.\n\n\n\nWhile using a prime number doesn’t guarantee perfect distribution or zero collisions, it significantly improves the hash function’s performance for many common types of input data (especially those with patterns or structures)."
  }
]