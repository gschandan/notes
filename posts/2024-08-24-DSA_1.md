---
categories:
  - DSA
  - data structures
  - introduction
date: '2024-08-24'
description: Data Structures and Algorithms - Basic Data Structures
layout: post
title: Basic Data Structures
toc: true
format:
  html:
    html-math-method: katex
---

# DSA

## Introduction

Data structures provide an organised format for data storage, management and access. Most of the following data structures are used in four basic ways:

1. Access - provided a location, return the item at that location, or alternatively, return all the items
2. Search - look for a specific item or value, and it's location
3. Insert - add an item into the collection i.e. at the start, end or in between
4. Delete - remove an item from the collection

Transformations like sorting and filtering can also be performed. The following are some common and basic data structures:

### Arrays

#### General Arrays

Arrays are collections of items, typically stored in contiguous memory:

| Index | 0 | 1 | 2 | 3 | 4 |
|-------|---|---|---|---|---|
| Value | 'h' | 'e' | 'l' | 'l' | 'o' |

Efficiencies:

- Access: $O(1)$
- Search: $O(n)$
- Insertion: $O(n)$
- Deletion: $O(n)$


##### Unordered Array

Elements are stored in no particular order.

| Index | 0 | 1 | 2 | 3 | 4 | 5 |
|-------|---|---|---|---|---|---|
| Value | 7 | 2 | 9 | 4 | 5 | 1 |


- Insertion: $O(1)$ (add to the end)  
- Deletion: $O(n)$ (need to shift elements)  
- Search: $O(n)$ (linear search)  

##### Ordered (Sorted) Array

Elements are stored in a specific order, typically ascending or descending.

| Index | 0 | 1 | 2 | 3 | 4 | 5 |
|-------|---|---|---|---|---|---|
| Value | 1 | 2 | 4 | 5 | 7 | 9 |

- Insertion: $O(n)$ (find position and shift elements)  
- Deletion: $O(n)$ (shift elements after deletion)  
- Search: $O(\log n)$ (binary search)  

##### Circular Array

The last element is conceptually followed by the first element, forming a circle.

    ┌───┐
┌───┤ 5 ├───┐
│ 4 │   │ 1 │
├───┤   ├───┤
│ 3 │   │ 2 │
└───┴───┴───┘

- Useful for queue implementations  
- Efficient use of fixed-size array  
- Operations wrap around the end of the array  

##### Jagged Array (Array of Arrays)

An array where each element is an array, possibly of different lengths.

| Index | Array                |
|-------|----------------------|
|   0   | [1, 2, 3]            |
|   1   | [4, 5]               |
|   2   | [6, 7, 8, 9]         |
|   3   | [10]                 |


- Flexible structure for 2D data with varying row lengths
- Efficient for sparse matrices
- Access: $O(1)$ for both dimensions

##### Parallel Arrays

Multiple arrays used to store related data side by side.

Names:  | "Alice" | "Bob" | "Charlie" | "David" |
Ages:   |   25    |  30   |    22     |   28    |
Scores: |   95    |  88   |    91     |   79    |

- Simple alternative to array of structures  
- Good cache locality for operations on a single attribute  
- Requires careful management to keep arrays synchronized  

##### Sparse Array

An array where most elements have the same value (usually zero).

Logical view:
| 0 | 0 | 0 | 3 | 0 | 0 | 1 | 0 | 0 | 2 | 0 |

Actual storage (index-value pairs):
| 3:3 | 6:1 | 9:2 |

- Space-efficient for sparse data  
- Slower access time compared to standard arrays  

### Sets

#### Array-based Sets

Array based sets are collections of items, stored in contiguous memory, that do not allow duplicate item to be inserted, and may or may not be sorted:

Unsorted:
| Index | 0 | 1 | 2 | 3 | 4 |
|-------|---|---|---|---|---|
| Value | 5 | 2 | 8 | 1 | 3 |

Sorted:
| Index | 0 | 1 | 2 | 3 | 4 |
|-------|---|---|---|---|---|
| Value | 1 | 2 | 3 | 5 | 8 |

Every insert requires a search first to determine the value to be inserted does not already exist.

Efficiencies:

Access: $O(1)$
Insertion:
- Unsorted: $O(1)$ (append to end)
- Sorted: $O(n)$ (find correct position and shift elements, to maintain order)
Deletion: $O(n)$ (need to shift elements to fill the gap)
Search:
- Unsorted: $O(n)$
- Sorted: $O(\log n)$ (using binary search)

#### Hash Table-based Sets

Hash table-based sets use a @sec-hash-functions to map elements to indices in an array.

Hash function: $h(x) = x \mod 7$   
i.e. every input is divided by 7 and the remainder is the output of the hash function (output between 0 and 6)

| Index | Bucket |
|-------|--------|
|   0   |   7    |
|   1   |   1, 8 |
|   2   |   2    |
|   3   |   3    |
|   4   |        |
|   5   |   5    |
|   6   |        |

- Collision - in this example, there is a collision at index 1, with values 1 and 8 returning the same output and therefore being assigned to the same bucket.
- Empty bucket - important to monitor (or be aware) of the distribution of data which may indicate the hashing function may need to be altered if there are many empty buckets.


Efficiencies:

Access: N/A (sets don't typically support direct access)  
Insertion: $\theta(1)$ $O(n)$  
Deletion: $\theta(1)$ $O(n)$  
Search: $\theta(1)$ $O(n)$  

#### Hash Functions{#sec-hash-functions}

### Linked List

A linked list consists of nodes where each node contains a data field and a reference to the next node in the sequence.

```markdown
[3] -> [7] -> [1] -> [9] -> [4] -> null
```

Access: $O(n)$
Search: $O(n)$
Insertion: $O(1)$
Deletion: $O(1)$

### Stack

A stack follows the Last In First Out (LIFO) principle.

```markdown
| 4 | <- Top
| 9 |
| 1 |
| 7 |
| 3 |
```

Push: $O(1)$
Pop: $O(1)$
Peek: $O(1)$

### Queue

A queue follows the First In First Out (FIFO) principle.

```markdown
Front -> [3] -> [7] -> [1] -> [9] -> [4] <- Rear
```

Enqueue: $O(1)$
Dequeue: $O(1)$
Front: $O(1)$

### Tree

A tree is a hierarchical structure with a root node and child nodes.

```markdown
    1
   / \
  2   3
 / \   \
4   5   6
```

Access: $O(\log n)$ (for balanced trees)
Search: $O(\log n)$ (for balanced trees)
Insertion: $O(\log n)$ (for balanced trees)
Deletion: $O(\log n)$ (for balanced trees)

### Graph

A graph consists of vertices connected by edges.

```markdown
    A --- B
    |   / |
    |  /  |
    | /   |
    C --- D
```

Traversal: $O(V + E)$ where $V$ is the number of vertices and $E$ is the number of edges

### Hash Table

A hash table stores key-value pairs and uses a hash function to compute an index into an array of buckets.

```markdown
| Key | Hash | Index | Value |
|-----|------|-------|-------|
| "apple" | hash("apple") | 2 | 5 |
| "banana" | hash("banana") | 4 | 8 |
| "cherry" | hash("cherry") | 1 | 3 |
```

Access: $O(1)$ average case, $O(n)$ worst case
Search: $O(1)$ average case, $O(n)$ worst case
Insertion: $O(1)$ average case, $O(n)$ worst case
Deletion: $O(1)$ average case, $O(n)$ worst case

# References

[^1] J. Wengrow, 2017, A Common-Sense Guide to Data Structures and Algorithms  
